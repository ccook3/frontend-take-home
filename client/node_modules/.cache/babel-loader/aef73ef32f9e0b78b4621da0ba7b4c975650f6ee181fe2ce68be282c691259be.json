{"ast":null,"code":"\"use strict\";\n\"use client\";\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n// If the importer is in node compatibility mode or this is not an ESM\n// file that has been converted to a CommonJS file using a Babel-\n// compatible transform (i.e. \"__esModule\" has not been set), then set\n// \"default\" to the CommonJS \"module.exports\" for node compatibility.\nisNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// packages/react/roving-focus/src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  Item: () => Item,\n  Root: () => Root,\n  RovingFocusGroup: () => RovingFocusGroup,\n  RovingFocusGroupItem: () => RovingFocusGroupItem,\n  createRovingFocusGroupScope: () => createRovingFocusGroupScope\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// packages/react/roving-focus/src/roving-focus-group.tsx\nvar React = __toESM(require(\"react\"));\nvar import_primitive = require(\"@radix-ui/primitive\");\nvar import_react_collection = require(\"@radix-ui/react-collection\");\nvar import_react_compose_refs = require(\"@radix-ui/react-compose-refs\");\nvar import_react_context = require(\"@radix-ui/react-context\");\nvar import_react_id = require(\"@radix-ui/react-id\");\nvar import_react_primitive = require(\"@radix-ui/react-primitive\");\nvar import_react_use_callback_ref = require(\"@radix-ui/react-use-callback-ref\");\nvar import_react_use_controllable_state = require(\"@radix-ui/react-use-controllable-state\");\nvar import_react_direction = require(\"@radix-ui/react-direction\");\nvar import_jsx_runtime = require(\"react/jsx-runtime\");\nvar ENTRY_FOCUS = \"rovingFocusGroup.onEntryFocus\";\nvar EVENT_OPTIONS = {\n  bubbles: false,\n  cancelable: true\n};\nvar GROUP_NAME = \"RovingFocusGroup\";\nvar [Collection, useCollection, createCollectionScope] = (0, import_react_collection.createCollection)(GROUP_NAME);\nvar [createRovingFocusGroupContext, createRovingFocusGroupScope] = (0, import_react_context.createContextScope)(GROUP_NAME, [createCollectionScope]);\nvar [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);\nvar RovingFocusGroup = React.forwardRef((props, forwardedRef) => {\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(Collection.Provider, {\n    scope: props.__scopeRovingFocusGroup,\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(Collection.Slot, {\n      scope: props.__scopeRovingFocusGroup,\n      children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(RovingFocusGroupImpl, {\n        ...props,\n        ref: forwardedRef\n      })\n    })\n  });\n});\nRovingFocusGroup.displayName = GROUP_NAME;\nvar RovingFocusGroupImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    loop = false,\n    dir,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    preventScrollOnEntryFocus = false,\n    ...groupProps\n  } = props;\n  const ref = React.useRef(null);\n  const composedRefs = (0, import_react_compose_refs.useComposedRefs)(forwardedRef, ref);\n  const direction = (0, import_react_direction.useDirection)(dir);\n  const [currentTabStopId = null, setCurrentTabStopId] = (0, import_react_use_controllable_state.useControllableState)({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId,\n    onChange: onCurrentTabStopIdChange\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = (0, import_react_use_callback_ref.useCallbackRef)(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(RovingFocusProvider, {\n    scope: __scopeRovingFocusGroup,\n    orientation,\n    dir: direction,\n    loop,\n    currentTabStopId,\n    onItemFocus: React.useCallback(tabStopId => setCurrentTabStopId(tabStopId), [setCurrentTabStopId]),\n    onItemShiftTab: React.useCallback(() => setIsTabbingBackOut(true), []),\n    onFocusableItemAdd: React.useCallback(() => setFocusableItemsCount(prevCount => prevCount + 1), []),\n    onFocusableItemRemove: React.useCallback(() => setFocusableItemsCount(prevCount => prevCount - 1), []),\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_primitive.Primitive.div, {\n      tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,\n      \"data-orientation\": orientation,\n      ...groupProps,\n      ref: composedRefs,\n      style: {\n        outline: \"none\",\n        ...props.style\n      },\n      onMouseDown: (0, import_primitive.composeEventHandlers)(props.onMouseDown, () => {\n        isClickFocusRef.current = true;\n      }),\n      onFocus: (0, import_primitive.composeEventHandlers)(props.onFocus, event => {\n        const isKeyboardFocus = !isClickFocusRef.current;\n        if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n          const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n          event.currentTarget.dispatchEvent(entryFocusEvent);\n          if (!entryFocusEvent.defaultPrevented) {\n            const items = getItems().filter(item => item.focusable);\n            const activeItem = items.find(item => item.active);\n            const currentItem = items.find(item => item.id === currentTabStopId);\n            const candidateItems = [activeItem, currentItem, ...items].filter(Boolean);\n            const candidateNodes = candidateItems.map(item => item.ref.current);\n            focusFirst(candidateNodes, preventScrollOnEntryFocus);\n          }\n        }\n        isClickFocusRef.current = false;\n      }),\n      onBlur: (0, import_primitive.composeEventHandlers)(props.onBlur, () => setIsTabbingBackOut(false))\n    })\n  });\n});\nvar ITEM_NAME = \"RovingFocusGroupItem\";\nvar RovingFocusGroupItem = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    focusable = true,\n    active = false,\n    tabStopId,\n    ...itemProps\n  } = props;\n  const autoId = (0, import_react_id.useId)();\n  const id = tabStopId || autoId;\n  const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n  const isCurrentTabStop = context.currentTabStopId === id;\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const {\n    onFocusableItemAdd,\n    onFocusableItemRemove\n  } = context;\n  React.useEffect(() => {\n    if (focusable) {\n      onFocusableItemAdd();\n      return () => onFocusableItemRemove();\n    }\n  }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(Collection.ItemSlot, {\n    scope: __scopeRovingFocusGroup,\n    id,\n    focusable,\n    active,\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_primitive.Primitive.span, {\n      tabIndex: isCurrentTabStop ? 0 : -1,\n      \"data-orientation\": context.orientation,\n      ...itemProps,\n      ref: forwardedRef,\n      onMouseDown: (0, import_primitive.composeEventHandlers)(props.onMouseDown, event => {\n        if (!focusable) event.preventDefault();else context.onItemFocus(id);\n      }),\n      onFocus: (0, import_primitive.composeEventHandlers)(props.onFocus, () => context.onItemFocus(id)),\n      onKeyDown: (0, import_primitive.composeEventHandlers)(props.onKeyDown, event => {\n        if (event.key === \"Tab\" && event.shiftKey) {\n          context.onItemShiftTab();\n          return;\n        }\n        if (event.target !== event.currentTarget) return;\n        const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n        if (focusIntent !== void 0) {\n          if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;\n          event.preventDefault();\n          const items = getItems().filter(item => item.focusable);\n          let candidateNodes = items.map(item => item.ref.current);\n          if (focusIntent === \"last\") candidateNodes.reverse();else if (focusIntent === \"prev\" || focusIntent === \"next\") {\n            if (focusIntent === \"prev\") candidateNodes.reverse();\n            const currentIndex = candidateNodes.indexOf(event.currentTarget);\n            candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);\n          }\n          setTimeout(() => focusFirst(candidateNodes));\n        }\n      })\n    })\n  });\n});\nRovingFocusGroupItem.displayName = ITEM_NAME;\nvar MAP_KEY_TO_FOCUS_INTENT = {\n  ArrowLeft: \"prev\",\n  ArrowUp: \"prev\",\n  ArrowRight: \"next\",\n  ArrowDown: \"next\",\n  PageUp: \"first\",\n  Home: \"first\",\n  PageDown: \"last\",\n  End: \"last\"\n};\nfunction getDirectionAwareKey(key, dir) {\n  if (dir !== \"rtl\") return key;\n  return key === \"ArrowLeft\" ? \"ArrowRight\" : key === \"ArrowRight\" ? \"ArrowLeft\" : key;\n}\nfunction getFocusIntent(event, orientation, dir) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === \"vertical\" && [\"ArrowLeft\", \"ArrowRight\"].includes(key)) return void 0;\n  if (orientation === \"horizontal\" && [\"ArrowUp\", \"ArrowDown\"].includes(key)) return void 0;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\nfunction focusFirst(candidates, preventScroll = false) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus({\n      preventScroll\n    });\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\nfunction wrapArray(array, startIndex) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\nvar Root = RovingFocusGroup;\nvar Item = RovingFocusGroupItem;","map":{"version":3,"names":["src_exports","__export","Item","Root","RovingFocusGroup","RovingFocusGroupItem","createRovingFocusGroupScope","module","exports","__toCommonJS","React","__toESM","require","import_primitive","import_react_collection","import_react_compose_refs","import_react_context","import_react_id","import_react_primitive","import_react_use_callback_ref","import_react_use_controllable_state","import_react_direction","import_jsx_runtime","ENTRY_FOCUS","EVENT_OPTIONS","bubbles","cancelable","GROUP_NAME","Collection","useCollection","createCollectionScope","createCollection","createRovingFocusGroupContext","createContextScope","RovingFocusProvider","useRovingFocusContext","forwardRef","props","forwardedRef","jsx","Provider","scope","__scopeRovingFocusGroup","children","Slot","RovingFocusGroupImpl","ref","displayName","orientation","loop","dir","currentTabStopId","currentTabStopIdProp","defaultCurrentTabStopId","onCurrentTabStopIdChange","onEntryFocus","preventScrollOnEntryFocus","groupProps","useRef","composedRefs","useComposedRefs","direction","useDirection","setCurrentTabStopId","useControllableState","prop","defaultProp","onChange","isTabbingBackOut","setIsTabbingBackOut","useState","handleEntryFocus","useCallbackRef","getItems","isClickFocusRef","focusableItemsCount","setFocusableItemsCount","useEffect","node","current","addEventListener","removeEventListener","onItemFocus","useCallback","tabStopId","onItemShiftTab","onFocusableItemAdd","prevCount","onFocusableItemRemove","Primitive","div","tabIndex","style","outline","onMouseDown","composeEventHandlers","onFocus","event","isKeyboardFocus","target","currentTarget","entryFocusEvent","CustomEvent","dispatchEvent","defaultPrevented","items","filter","item","focusable","activeItem","find","active","currentItem","id","candidateItems","Boolean","candidateNodes","map","focusFirst","onBlur","ITEM_NAME","itemProps","autoId","useId","context","isCurrentTabStop","ItemSlot","span","preventDefault","onKeyDown","key","shiftKey","focusIntent","getFocusIntent","metaKey","ctrlKey","altKey","reverse","currentIndex","indexOf","wrapArray","slice","setTimeout","MAP_KEY_TO_FOCUS_INTENT","ArrowLeft","ArrowUp","ArrowRight","ArrowDown","PageUp","Home","PageDown","End","getDirectionAwareKey","includes","candidates","preventScroll","PREVIOUSLY_FOCUSED_ELEMENT","document","activeElement","candidate","focus","array","startIndex","_","index","length"],"sources":["/Users/catiecook/Documents/workos/frontend-take-home/client/node_modules/@radix-ui/react-roving-focus/src/index.ts","/Users/catiecook/Documents/workos/frontend-take-home/client/node_modules/@radix-ui/react-roving-focus/src/roving-focus-group.tsx"],"sourcesContent":["'use client';\nexport {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n} from './roving-focus-group';\nexport type { RovingFocusGroupProps, RovingFocusItemProps } from './roving-focus-group';\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-direction';\n\nimport type { Scope } from '@radix-ui/react-context';\n\nconst ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'RovingFocusGroup';\n\ntype ItemData = { id: string; focusable: boolean; active: boolean };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  HTMLSpanElement,\n  ItemData\n>(GROUP_NAME);\n\ntype ScopedProps<P> = P & { __scopeRovingFocusGroup?: Scope };\nconst [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(\n  GROUP_NAME,\n  [createCollectionScope]\n);\n\ntype Orientation = React.AriaAttributes['aria-orientation'];\ntype Direction = 'ltr' | 'rtl';\n\ninterface RovingFocusGroupOptions {\n  /**\n   * The orientation of the group.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   */\n  orientation?: Orientation;\n  /**\n   * The direction of navigation between items.\n   */\n  dir?: Direction;\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: boolean;\n}\n\ntype RovingContextValue = RovingFocusGroupOptions & {\n  currentTabStopId: string | null;\n  onItemFocus(tabStopId: string): void;\n  onItemShiftTab(): void;\n  onFocusableItemAdd(): void;\n  onFocusableItemRemove(): void;\n};\n\nconst [RovingFocusProvider, useRovingFocusContext] =\n  createRovingFocusGroupContext<RovingContextValue>(GROUP_NAME);\n\ntype RovingFocusGroupElement = RovingFocusGroupImplElement;\ninterface RovingFocusGroupProps extends RovingFocusGroupImplProps {}\n\nconst RovingFocusGroup = React.forwardRef<RovingFocusGroupElement, RovingFocusGroupProps>(\n  (props: ScopedProps<RovingFocusGroupProps>, forwardedRef) => {\n    return (\n      <Collection.Provider scope={props.__scopeRovingFocusGroup}>\n        <Collection.Slot scope={props.__scopeRovingFocusGroup}>\n          <RovingFocusGroupImpl {...props} ref={forwardedRef} />\n        </Collection.Slot>\n      </Collection.Provider>\n    );\n  }\n);\n\nRovingFocusGroup.displayName = GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype RovingFocusGroupImplElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface RovingFocusGroupImplProps\n  extends Omit<PrimitiveDivProps, 'dir'>,\n    RovingFocusGroupOptions {\n  currentTabStopId?: string | null;\n  defaultCurrentTabStopId?: string;\n  onCurrentTabStopIdChange?: (tabStopId: string | null) => void;\n  onEntryFocus?: (event: Event) => void;\n  preventScrollOnEntryFocus?: boolean;\n}\n\nconst RovingFocusGroupImpl = React.forwardRef<\n  RovingFocusGroupImplElement,\n  RovingFocusGroupImplProps\n>((props: ScopedProps<RovingFocusGroupImplProps>, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    loop = false,\n    dir,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    preventScrollOnEntryFocus = false,\n    ...groupProps\n  } = props;\n  const ref = React.useRef<RovingFocusGroupImplElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const direction = useDirection(dir);\n  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId,\n    onChange: onCurrentTabStopIdChange,\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n\n  return (\n    <RovingFocusProvider\n      scope={__scopeRovingFocusGroup}\n      orientation={orientation}\n      dir={direction}\n      loop={loop}\n      currentTabStopId={currentTabStopId}\n      onItemFocus={React.useCallback(\n        (tabStopId) => setCurrentTabStopId(tabStopId),\n        [setCurrentTabStopId]\n      )}\n      onItemShiftTab={React.useCallback(() => setIsTabbingBackOut(true), [])}\n      onFocusableItemAdd={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount + 1),\n        []\n      )}\n      onFocusableItemRemove={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount - 1),\n        []\n      )}\n    >\n      <Primitive.div\n        tabIndex={isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0}\n        data-orientation={orientation}\n        {...groupProps}\n        ref={composedRefs}\n        style={{ outline: 'none', ...props.style }}\n        onMouseDown={composeEventHandlers(props.onMouseDown, () => {\n          isClickFocusRef.current = true;\n        })}\n        onFocus={composeEventHandlers(props.onFocus, (event) => {\n          // We normally wouldn't need this check, because we already check\n          // that the focus is on the current target and not bubbling to it.\n          // We do this because Safari doesn't focus buttons when clicked, and\n          // instead, the wrapper will get focused and not through a bubbling event.\n          const isKeyboardFocus = !isClickFocusRef.current;\n\n          if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n            const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n            event.currentTarget.dispatchEvent(entryFocusEvent);\n\n            if (!entryFocusEvent.defaultPrevented) {\n              const items = getItems().filter((item) => item.focusable);\n              const activeItem = items.find((item) => item.active);\n              const currentItem = items.find((item) => item.id === currentTabStopId);\n              const candidateItems = [activeItem, currentItem, ...items].filter(\n                Boolean\n              ) as typeof items;\n              const candidateNodes = candidateItems.map((item) => item.ref.current!);\n              focusFirst(candidateNodes, preventScrollOnEntryFocus);\n            }\n          }\n\n          isClickFocusRef.current = false;\n        })}\n        onBlur={composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))}\n      />\n    </RovingFocusProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RovingFocusGroupItem';\n\ntype RovingFocusItemElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface RovingFocusItemProps extends PrimitiveSpanProps {\n  tabStopId?: string;\n  focusable?: boolean;\n  active?: boolean;\n}\n\nconst RovingFocusGroupItem = React.forwardRef<RovingFocusItemElement, RovingFocusItemProps>(\n  (props: ScopedProps<RovingFocusItemProps>, forwardedRef) => {\n    const {\n      __scopeRovingFocusGroup,\n      focusable = true,\n      active = false,\n      tabStopId,\n      ...itemProps\n    } = props;\n    const autoId = useId();\n    const id = tabStopId || autoId;\n    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = useCollection(__scopeRovingFocusGroup);\n\n    const { onFocusableItemAdd, onFocusableItemRemove } = context;\n\n    React.useEffect(() => {\n      if (focusable) {\n        onFocusableItemAdd();\n        return () => onFocusableItemRemove();\n      }\n    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeRovingFocusGroup}\n        id={id}\n        focusable={focusable}\n        active={active}\n      >\n        <Primitive.span\n          tabIndex={isCurrentTabStop ? 0 : -1}\n          data-orientation={context.orientation}\n          {...itemProps}\n          ref={forwardedRef}\n          onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n            // We prevent focusing non-focusable items on `mousedown`.\n            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n            if (!focusable) event.preventDefault();\n            // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n            else context.onItemFocus(id);\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => context.onItemFocus(id))}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (event.key === 'Tab' && event.shiftKey) {\n              context.onItemShiftTab();\n              return;\n            }\n\n            if (event.target !== event.currentTarget) return;\n\n            const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n\n            if (focusIntent !== undefined) {\n              if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;\n              event.preventDefault();\n              const items = getItems().filter((item) => item.focusable);\n              let candidateNodes = items.map((item) => item.ref.current!);\n\n              if (focusIntent === 'last') candidateNodes.reverse();\n              else if (focusIntent === 'prev' || focusIntent === 'next') {\n                if (focusIntent === 'prev') candidateNodes.reverse();\n                const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                candidateNodes = context.loop\n                  ? wrapArray(candidateNodes, currentIndex + 1)\n                  : candidateNodes.slice(currentIndex + 1);\n              }\n\n              /**\n               * Imperative focus during keydown is risky so we prevent React's batching updates\n               * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n               */\n              setTimeout(() => focusFirst(candidateNodes));\n            }\n          })}\n        />\n      </Collection.ItemSlot>\n    );\n  }\n);\n\nRovingFocusGroupItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\n// prettier-ignore\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\n  ArrowLeft: 'prev', ArrowUp: 'prev',\n  ArrowRight: 'next', ArrowDown: 'next',\n  PageUp: 'first', Home: 'first',\n  PageDown: 'last', End: 'last',\n};\n\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\n  if (dir !== 'rtl') return key;\n  return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\n\ntype FocusIntent = 'first' | 'last' | 'prev' | 'next';\n\nfunction getFocusIntent(event: React.KeyboardEvent, orientation?: Orientation, dir?: Direction) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return undefined;\n  if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return undefined;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\n\nfunction focusFirst(candidates: HTMLElement[], preventScroll = false) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus({ preventScroll });\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\nconst Root = RovingFocusGroup;\nconst Item = RovingFocusGroupItem;\n\nexport {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n};\nexport type { RovingFocusGroupProps, RovingFocusItemProps };\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAAA,WAAA;AAAAC,QAAA,CAAAD,WAAA;EAAAE,IAAA,EAAAA,CAAA,KAAAA,IAAA;EAAAC,IAAA,EAAAA,CAAA,KAAAA,IAAA;EAAAC,gBAAA,EAAAA,CAAA,KAAAA,gBAAA;EAAAC,oBAAA,EAAAA,CAAA,KAAAA,oBAAA;EAAAC,2BAAA,EAAAA,CAAA,KAAAA;AAAA;AAAAC,MAAA,CAAAC,OAAA,GAAAC,YAAA,CAAAT,WAAA;;;ACAA,IAAAU,KAAA,GAAuBC,OAAA,CAAAC,OAAA;AACvB,IAAAC,gBAAA,GAAqCD,OAAA;AACrC,IAAAE,uBAAA,GAAiCF,OAAA;AACjC,IAAAG,yBAAA,GAAgCH,OAAA;AAChC,IAAAI,oBAAA,GAAmCJ,OAAA;AACnC,IAAAK,eAAA,GAAsBL,OAAA;AACtB,IAAAM,sBAAA,GAA0BN,OAAA;AAC1B,IAAAO,6BAAA,GAA+BP,OAAA;AAC/B,IAAAQ,mCAAA,GAAqCR,OAAA;AACrC,IAAAS,sBAAA,GAA6BT,OAAA;AAgEnB,IAAAU,kBAAA,GAAAV,OAAA;AA5DV,IAAMW,WAAA,GAAc;AACpB,IAAMC,aAAA,GAAgB;EAAEC,OAAA,EAAS;EAAOC,UAAA,EAAY;AAAK;AAMzD,IAAMC,UAAA,GAAa;AAGnB,IAAM,CAACC,UAAA,EAAYC,aAAA,EAAeC,qBAAqB,QAAIhB,uBAAA,CAAAiB,gBAAA,EAGzDJ,UAAU;AAGZ,IAAM,CAACK,6BAAA,EAA+B1B,2BAA2B,QAAIU,oBAAA,CAAAiB,kBAAA,EACnEN,UAAA,EACA,CAACG,qBAAqB,CACxB;AA8BA,IAAM,CAACI,mBAAA,EAAqBC,qBAAqB,IAC/CH,6BAAA,CAAkDL,UAAU;AAK9D,IAAMvB,gBAAA,GAAyBM,KAAA,CAAA0B,UAAA,CAC7B,CAACC,KAAA,EAA2CC,YAAA,KAAiB;EAC3D,OACE,mBAAAhB,kBAAA,CAAAiB,GAAA,EAACX,UAAA,CAAWY,QAAA,EAAX;IAAoBC,KAAA,EAAOJ,KAAA,CAAMK,uBAAA;IAChCC,QAAA,qBAAArB,kBAAA,CAAAiB,GAAA,EAACX,UAAA,CAAWgB,IAAA,EAAX;MAAgBH,KAAA,EAAOJ,KAAA,CAAMK,uBAAA;MAC5BC,QAAA,qBAAArB,kBAAA,CAAAiB,GAAA,EAACM,oBAAA;QAAsB,GAAGR,KAAA;QAAOS,GAAA,EAAKR;MAAA,CAAc;IAAA,CACtD;EAAA,CACF;AAEJ,CACF;AAEAlC,gBAAA,CAAiB2C,WAAA,GAAcpB,UAAA;AAgB/B,IAAMkB,oBAAA,GAA6BnC,KAAA,CAAA0B,UAAA,CAGjC,CAACC,KAAA,EAA+CC,YAAA,KAAiB;EACjE,MAAM;IACJI,uBAAA;IACAM,WAAA;IACAC,IAAA,GAAO;IACPC,GAAA;IACAC,gBAAA,EAAkBC,oBAAA;IAClBC,uBAAA;IACAC,wBAAA;IACAC,YAAA;IACAC,yBAAA,GAA4B;IAC5B,GAAGC;EACL,IAAIpB,KAAA;EACJ,MAAMS,GAAA,GAAYpC,KAAA,CAAAgD,MAAA,CAAoC,IAAI;EAC1D,MAAMC,YAAA,OAAe5C,yBAAA,CAAA6C,eAAA,EAAgBtB,YAAA,EAAcQ,GAAG;EACtD,MAAMe,SAAA,OAAYxC,sBAAA,CAAAyC,YAAA,EAAaZ,GAAG;EAClC,MAAM,CAACC,gBAAA,GAAmB,MAAMY,mBAAmB,QAAI3C,mCAAA,CAAA4C,oBAAA,EAAqB;IAC1EC,IAAA,EAAMb,oBAAA;IACNc,WAAA,EAAab,uBAAA;IACbc,QAAA,EAAUb;EACZ,CAAC;EACD,MAAM,CAACc,gBAAA,EAAkBC,mBAAmB,IAAU3D,KAAA,CAAA4D,QAAA,CAAS,KAAK;EACpE,MAAMC,gBAAA,OAAmBpD,6BAAA,CAAAqD,cAAA,EAAejB,YAAY;EACpD,MAAMkB,QAAA,GAAW5C,aAAA,CAAca,uBAAuB;EACtD,MAAMgC,eAAA,GAAwBhE,KAAA,CAAAgD,MAAA,CAAO,KAAK;EAC1C,MAAM,CAACiB,mBAAA,EAAqBC,sBAAsB,IAAUlE,KAAA,CAAA4D,QAAA,CAAS,CAAC;EAEhE5D,KAAA,CAAAmE,SAAA,CAAU,MAAM;IACpB,MAAMC,IAAA,GAAOhC,GAAA,CAAIiC,OAAA;IACjB,IAAID,IAAA,EAAM;MACRA,IAAA,CAAKE,gBAAA,CAAiBzD,WAAA,EAAagD,gBAAgB;MACnD,OAAO,MAAMO,IAAA,CAAKG,mBAAA,CAAoB1D,WAAA,EAAagD,gBAAgB;IACrE;EACF,GAAG,CAACA,gBAAgB,CAAC;EAErB,OACE,mBAAAjD,kBAAA,CAAAiB,GAAA,EAACL,mBAAA;IACCO,KAAA,EAAOC,uBAAA;IACPM,WAAA;IACAE,GAAA,EAAKW,SAAA;IACLZ,IAAA;IACAE,gBAAA;IACA+B,WAAA,EAAmBxE,KAAA,CAAAyE,WAAA,CAChBC,SAAA,IAAcrB,mBAAA,CAAoBqB,SAAS,GAC5C,CAACrB,mBAAmB,CACtB;IACAsB,cAAA,EAAsB3E,KAAA,CAAAyE,WAAA,CAAY,MAAMd,mBAAA,CAAoB,IAAI,GAAG,EAAE;IACrEiB,kBAAA,EAA0B5E,KAAA,CAAAyE,WAAA,CACxB,MAAMP,sBAAA,CAAwBW,SAAA,IAAcA,SAAA,GAAY,CAAC,GACzD,EACF;IACAC,qBAAA,EAA6B9E,KAAA,CAAAyE,WAAA,CAC3B,MAAMP,sBAAA,CAAwBW,SAAA,IAAcA,SAAA,GAAY,CAAC,GACzD,EACF;IAEA5C,QAAA,qBAAArB,kBAAA,CAAAiB,GAAA,EAACrB,sBAAA,CAAAuE,SAAA,CAAUC,GAAA,EAAV;MACCC,QAAA,EAAUvB,gBAAA,IAAoBO,mBAAA,KAAwB,IAAI,KAAK;MAC/D,oBAAkB3B,WAAA;MACjB,GAAGS,UAAA;MACJX,GAAA,EAAKa,YAAA;MACLiC,KAAA,EAAO;QAAEC,OAAA,EAAS;QAAQ,GAAGxD,KAAA,CAAMuD;MAAM;MACzCE,WAAA,MAAajF,gBAAA,CAAAkF,oBAAA,EAAqB1D,KAAA,CAAMyD,WAAA,EAAa,MAAM;QACzDpB,eAAA,CAAgBK,OAAA,GAAU;MAC5B,CAAC;MACDiB,OAAA,MAASnF,gBAAA,CAAAkF,oBAAA,EAAqB1D,KAAA,CAAM2D,OAAA,EAAUC,KAAA,IAAU;QAKtD,MAAMC,eAAA,GAAkB,CAACxB,eAAA,CAAgBK,OAAA;QAEzC,IAAIkB,KAAA,CAAME,MAAA,KAAWF,KAAA,CAAMG,aAAA,IAAiBF,eAAA,IAAmB,CAAC9B,gBAAA,EAAkB;UAChF,MAAMiC,eAAA,GAAkB,IAAIC,WAAA,CAAY/E,WAAA,EAAaC,aAAa;UAClEyE,KAAA,CAAMG,aAAA,CAAcG,aAAA,CAAcF,eAAe;UAEjD,IAAI,CAACA,eAAA,CAAgBG,gBAAA,EAAkB;YACrC,MAAMC,KAAA,GAAQhC,QAAA,CAAS,EAAEiC,MAAA,CAAQC,IAAA,IAASA,IAAA,CAAKC,SAAS;YACxD,MAAMC,UAAA,GAAaJ,KAAA,CAAMK,IAAA,CAAMH,IAAA,IAASA,IAAA,CAAKI,MAAM;YACnD,MAAMC,WAAA,GAAcP,KAAA,CAAMK,IAAA,CAAMH,IAAA,IAASA,IAAA,CAAKM,EAAA,KAAO9D,gBAAgB;YACrE,MAAM+D,cAAA,GAAiB,CAACL,UAAA,EAAYG,WAAA,EAAa,GAAGP,KAAK,EAAEC,MAAA,CACzDS,OACF;YACA,MAAMC,cAAA,GAAiBF,cAAA,CAAeG,GAAA,CAAKV,IAAA,IAASA,IAAA,CAAK7D,GAAA,CAAIiC,OAAQ;YACrEuC,UAAA,CAAWF,cAAA,EAAgB5D,yBAAyB;UACtD;QACF;QAEAkB,eAAA,CAAgBK,OAAA,GAAU;MAC5B,CAAC;MACDwC,MAAA,MAAQ1G,gBAAA,CAAAkF,oBAAA,EAAqB1D,KAAA,CAAMkF,MAAA,EAAQ,MAAMlD,mBAAA,CAAoB,KAAK,CAAC;IAAA,CAC7E;EAAA,CACF;AAEJ,CAAC;AAMD,IAAMmD,SAAA,GAAY;AAUlB,IAAMnH,oBAAA,GAA6BK,KAAA,CAAA0B,UAAA,CACjC,CAACC,KAAA,EAA0CC,YAAA,KAAiB;EAC1D,MAAM;IACJI,uBAAA;IACAkE,SAAA,GAAY;IACZG,MAAA,GAAS;IACT3B,SAAA;IACA,GAAGqC;EACL,IAAIpF,KAAA;EACJ,MAAMqF,MAAA,OAASzG,eAAA,CAAA0G,KAAA,EAAM;EACrB,MAAMV,EAAA,GAAK7B,SAAA,IAAasC,MAAA;EACxB,MAAME,OAAA,GAAUzF,qBAAA,CAAsBqF,SAAA,EAAW9E,uBAAuB;EACxE,MAAMmF,gBAAA,GAAmBD,OAAA,CAAQzE,gBAAA,KAAqB8D,EAAA;EACtD,MAAMxC,QAAA,GAAW5C,aAAA,CAAca,uBAAuB;EAEtD,MAAM;IAAE4C,kBAAA;IAAoBE;EAAsB,IAAIoC,OAAA;EAEhDlH,KAAA,CAAAmE,SAAA,CAAU,MAAM;IACpB,IAAI+B,SAAA,EAAW;MACbtB,kBAAA,CAAmB;MACnB,OAAO,MAAME,qBAAA,CAAsB;IACrC;EACF,GAAG,CAACoB,SAAA,EAAWtB,kBAAA,EAAoBE,qBAAqB,CAAC;EAEzD,OACE,mBAAAlE,kBAAA,CAAAiB,GAAA,EAACX,UAAA,CAAWkG,QAAA,EAAX;IACCrF,KAAA,EAAOC,uBAAA;IACPuE,EAAA;IACAL,SAAA;IACAG,MAAA;IAEApE,QAAA,qBAAArB,kBAAA,CAAAiB,GAAA,EAACrB,sBAAA,CAAAuE,SAAA,CAAUsC,IAAA,EAAV;MACCpC,QAAA,EAAUkC,gBAAA,GAAmB,IAAI;MACjC,oBAAkBD,OAAA,CAAQ5E,WAAA;MACzB,GAAGyE,SAAA;MACJ3E,GAAA,EAAKR,YAAA;MACLwD,WAAA,MAAajF,gBAAA,CAAAkF,oBAAA,EAAqB1D,KAAA,CAAMyD,WAAA,EAAcG,KAAA,IAAU;QAG9D,IAAI,CAACW,SAAA,EAAWX,KAAA,CAAM+B,cAAA,CAAe,OAEhCJ,OAAA,CAAQ1C,WAAA,CAAY+B,EAAE;MAC7B,CAAC;MACDjB,OAAA,MAASnF,gBAAA,CAAAkF,oBAAA,EAAqB1D,KAAA,CAAM2D,OAAA,EAAS,MAAM4B,OAAA,CAAQ1C,WAAA,CAAY+B,EAAE,CAAC;MAC1EgB,SAAA,MAAWpH,gBAAA,CAAAkF,oBAAA,EAAqB1D,KAAA,CAAM4F,SAAA,EAAYhC,KAAA,IAAU;QAC1D,IAAIA,KAAA,CAAMiC,GAAA,KAAQ,SAASjC,KAAA,CAAMkC,QAAA,EAAU;UACzCP,OAAA,CAAQvC,cAAA,CAAe;UACvB;QACF;QAEA,IAAIY,KAAA,CAAME,MAAA,KAAWF,KAAA,CAAMG,aAAA,EAAe;QAE1C,MAAMgC,WAAA,GAAcC,cAAA,CAAepC,KAAA,EAAO2B,OAAA,CAAQ5E,WAAA,EAAa4E,OAAA,CAAQ1E,GAAG;QAE1E,IAAIkF,WAAA,KAAgB,QAAW;UAC7B,IAAInC,KAAA,CAAMqC,OAAA,IAAWrC,KAAA,CAAMsC,OAAA,IAAWtC,KAAA,CAAMuC,MAAA,IAAUvC,KAAA,CAAMkC,QAAA,EAAU;UACtElC,KAAA,CAAM+B,cAAA,CAAe;UACrB,MAAMvB,KAAA,GAAQhC,QAAA,CAAS,EAAEiC,MAAA,CAAQC,IAAA,IAASA,IAAA,CAAKC,SAAS;UACxD,IAAIQ,cAAA,GAAiBX,KAAA,CAAMY,GAAA,CAAKV,IAAA,IAASA,IAAA,CAAK7D,GAAA,CAAIiC,OAAQ;UAE1D,IAAIqD,WAAA,KAAgB,QAAQhB,cAAA,CAAeqB,OAAA,CAAQ,WAC1CL,WAAA,KAAgB,UAAUA,WAAA,KAAgB,QAAQ;YACzD,IAAIA,WAAA,KAAgB,QAAQhB,cAAA,CAAeqB,OAAA,CAAQ;YACnD,MAAMC,YAAA,GAAetB,cAAA,CAAeuB,OAAA,CAAQ1C,KAAA,CAAMG,aAAa;YAC/DgB,cAAA,GAAiBQ,OAAA,CAAQ3E,IAAA,GACrB2F,SAAA,CAAUxB,cAAA,EAAgBsB,YAAA,GAAe,CAAC,IAC1CtB,cAAA,CAAeyB,KAAA,CAAMH,YAAA,GAAe,CAAC;UAC3C;UAMAI,UAAA,CAAW,MAAMxB,UAAA,CAAWF,cAAc,CAAC;QAC7C;MACF,CAAC;IAAA,CACH;EAAA,CACF;AAEJ,CACF;AAEA/G,oBAAA,CAAqB0C,WAAA,GAAcyE,SAAA;AAKnC,IAAMuB,uBAAA,GAAuD;EAC3DC,SAAA,EAAW;EAAQC,OAAA,EAAS;EAC5BC,UAAA,EAAY;EAAQC,SAAA,EAAW;EAC/BC,MAAA,EAAQ;EAASC,IAAA,EAAM;EACvBC,QAAA,EAAU;EAAQC,GAAA,EAAK;AACzB;AAEA,SAASC,qBAAqBtB,GAAA,EAAahF,GAAA,EAAiB;EAC1D,IAAIA,GAAA,KAAQ,OAAO,OAAOgF,GAAA;EAC1B,OAAOA,GAAA,KAAQ,cAAc,eAAeA,GAAA,KAAQ,eAAe,cAAcA,GAAA;AACnF;AAIA,SAASG,eAAepC,KAAA,EAA4BjD,WAAA,EAA2BE,GAAA,EAAiB;EAC9F,MAAMgF,GAAA,GAAMsB,oBAAA,CAAqBvD,KAAA,CAAMiC,GAAA,EAAKhF,GAAG;EAC/C,IAAIF,WAAA,KAAgB,cAAc,CAAC,aAAa,YAAY,EAAEyG,QAAA,CAASvB,GAAG,GAAG,OAAO;EACpF,IAAIlF,WAAA,KAAgB,gBAAgB,CAAC,WAAW,WAAW,EAAEyG,QAAA,CAASvB,GAAG,GAAG,OAAO;EACnF,OAAOa,uBAAA,CAAwBb,GAAG;AACpC;AAEA,SAASZ,WAAWoC,UAAA,EAA2BC,aAAA,GAAgB,OAAO;EACpE,MAAMC,0BAAA,GAA6BC,QAAA,CAASC,aAAA;EAC5C,WAAWC,SAAA,IAAaL,UAAA,EAAY;IAElC,IAAIK,SAAA,KAAcH,0BAAA,EAA4B;IAC9CG,SAAA,CAAUC,KAAA,CAAM;MAAEL;IAAc,CAAC;IACjC,IAAIE,QAAA,CAASC,aAAA,KAAkBF,0BAAA,EAA4B;EAC7D;AACF;AAMA,SAAShB,UAAaqB,KAAA,EAAYC,UAAA,EAAoB;EACpD,OAAOD,KAAA,CAAM5C,GAAA,CAAI,CAAC8C,CAAA,EAAGC,KAAA,KAAUH,KAAA,EAAOC,UAAA,GAAaE,KAAA,IAASH,KAAA,CAAMI,MAAM,CAAC;AAC3E;AAEA,IAAMlK,IAAA,GAAOC,gBAAA;AACb,IAAMF,IAAA,GAAOG,oBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}