{"ast":null,"code":"\"use strict\";\n\"use client\";\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n// If the importer is in node compatibility mode or this is not an ESM\n// file that has been converted to a CommonJS file using a Babel-\n// compatible transform (i.e. \"__esModule\" has not been set), then set\n// \"default\" to the CommonJS \"module.exports\" for node compatibility.\nisNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// packages/react/menu/src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  Anchor: () => Anchor2,\n  Arrow: () => Arrow2,\n  CheckboxItem: () => CheckboxItem,\n  Content: () => Content2,\n  Group: () => Group,\n  Item: () => Item2,\n  ItemIndicator: () => ItemIndicator,\n  Label: () => Label,\n  Menu: () => Menu,\n  MenuAnchor: () => MenuAnchor,\n  MenuArrow: () => MenuArrow,\n  MenuCheckboxItem: () => MenuCheckboxItem,\n  MenuContent: () => MenuContent,\n  MenuGroup: () => MenuGroup,\n  MenuItem: () => MenuItem,\n  MenuItemIndicator: () => MenuItemIndicator,\n  MenuLabel: () => MenuLabel,\n  MenuPortal: () => MenuPortal,\n  MenuRadioGroup: () => MenuRadioGroup,\n  MenuRadioItem: () => MenuRadioItem,\n  MenuSeparator: () => MenuSeparator,\n  MenuSub: () => MenuSub,\n  MenuSubContent: () => MenuSubContent,\n  MenuSubTrigger: () => MenuSubTrigger,\n  Portal: () => Portal,\n  RadioGroup: () => RadioGroup,\n  RadioItem: () => RadioItem,\n  Root: () => Root3,\n  Separator: () => Separator,\n  Sub: () => Sub,\n  SubContent: () => SubContent,\n  SubTrigger: () => SubTrigger,\n  createMenuScope: () => createMenuScope\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// packages/react/menu/src/menu.tsx\nvar React = __toESM(require(\"react\"));\nvar import_primitive = require(\"@radix-ui/primitive\");\nvar import_react_collection = require(\"@radix-ui/react-collection\");\nvar import_react_compose_refs = require(\"@radix-ui/react-compose-refs\");\nvar import_react_context = require(\"@radix-ui/react-context\");\nvar import_react_direction = require(\"@radix-ui/react-direction\");\nvar import_react_dismissable_layer = require(\"@radix-ui/react-dismissable-layer\");\nvar import_react_focus_guards = require(\"@radix-ui/react-focus-guards\");\nvar import_react_focus_scope = require(\"@radix-ui/react-focus-scope\");\nvar import_react_id = require(\"@radix-ui/react-id\");\nvar PopperPrimitive = __toESM(require(\"@radix-ui/react-popper\"));\nvar import_react_popper = require(\"@radix-ui/react-popper\");\nvar import_react_portal = require(\"@radix-ui/react-portal\");\nvar import_react_presence = require(\"@radix-ui/react-presence\");\nvar import_react_primitive = require(\"@radix-ui/react-primitive\");\nvar RovingFocusGroup = __toESM(require(\"@radix-ui/react-roving-focus\"));\nvar import_react_roving_focus = require(\"@radix-ui/react-roving-focus\");\nvar import_react_slot = require(\"@radix-ui/react-slot\");\nvar import_react_use_callback_ref = require(\"@radix-ui/react-use-callback-ref\");\nvar import_aria_hidden = require(\"aria-hidden\");\nvar import_react_remove_scroll = require(\"react-remove-scroll\");\nvar import_jsx_runtime = require(\"react/jsx-runtime\");\nvar SELECTION_KEYS = [\"Enter\", \" \"];\nvar FIRST_KEYS = [\"ArrowDown\", \"PageUp\", \"Home\"];\nvar LAST_KEYS = [\"ArrowUp\", \"PageDown\", \"End\"];\nvar FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nvar SUB_OPEN_KEYS = {\n  ltr: [...SELECTION_KEYS, \"ArrowRight\"],\n  rtl: [...SELECTION_KEYS, \"ArrowLeft\"]\n};\nvar SUB_CLOSE_KEYS = {\n  ltr: [\"ArrowLeft\"],\n  rtl: [\"ArrowRight\"]\n};\nvar MENU_NAME = \"Menu\";\nvar [Collection, useCollection, createCollectionScope] = (0, import_react_collection.createCollection)(MENU_NAME);\nvar [createMenuContext, createMenuScope] = (0, import_react_context.createContextScope)(MENU_NAME, [createCollectionScope, import_react_popper.createPopperScope, import_react_roving_focus.createRovingFocusGroupScope]);\nvar usePopperScope = (0, import_react_popper.createPopperScope)();\nvar useRovingFocusGroupScope = (0, import_react_roving_focus.createRovingFocusGroupScope)();\nvar [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);\nvar [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);\nvar Menu = props => {\n  const {\n    __scopeMenu,\n    open = false,\n    children,\n    dir,\n    onOpenChange,\n    modal = true\n  } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  const [content, setContent] = React.useState(null);\n  const isUsingKeyboardRef = React.useRef(false);\n  const handleOpenChange = (0, import_react_use_callback_ref.useCallbackRef)(onOpenChange);\n  const direction = (0, import_react_direction.useDirection)(dir);\n  React.useEffect(() => {\n    const handleKeyDown = () => {\n      isUsingKeyboardRef.current = true;\n      document.addEventListener(\"pointerdown\", handlePointer, {\n        capture: true,\n        once: true\n      });\n      document.addEventListener(\"pointermove\", handlePointer, {\n        capture: true,\n        once: true\n      });\n    };\n    const handlePointer = () => isUsingKeyboardRef.current = false;\n    document.addEventListener(\"keydown\", handleKeyDown, {\n      capture: true\n    });\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown, {\n        capture: true\n      });\n      document.removeEventListener(\"pointerdown\", handlePointer, {\n        capture: true\n      });\n      document.removeEventListener(\"pointermove\", handlePointer, {\n        capture: true\n      });\n    };\n  }, []);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(PopperPrimitive.Root, {\n    ...popperScope,\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(MenuProvider, {\n      scope: __scopeMenu,\n      open,\n      onOpenChange: handleOpenChange,\n      content,\n      onContentChange: setContent,\n      children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(MenuRootProvider, {\n        scope: __scopeMenu,\n        onClose: React.useCallback(() => handleOpenChange(false), [handleOpenChange]),\n        isUsingKeyboardRef,\n        dir: direction,\n        modal,\n        children\n      })\n    })\n  });\n};\nMenu.displayName = MENU_NAME;\nvar ANCHOR_NAME = \"MenuAnchor\";\nvar MenuAnchor = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    ...anchorProps\n  } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(PopperPrimitive.Anchor, {\n    ...popperScope,\n    ...anchorProps,\n    ref: forwardedRef\n  });\n});\nMenuAnchor.displayName = ANCHOR_NAME;\nvar PORTAL_NAME = \"MenuPortal\";\nvar [PortalProvider, usePortalContext] = createMenuContext(PORTAL_NAME, {\n  forceMount: void 0\n});\nvar MenuPortal = props => {\n  const {\n    __scopeMenu,\n    forceMount,\n    children,\n    container\n  } = props;\n  const context = useMenuContext(PORTAL_NAME, __scopeMenu);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(PortalProvider, {\n    scope: __scopeMenu,\n    forceMount,\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_presence.Presence, {\n      present: forceMount || context.open,\n      children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_portal.Portal, {\n        asChild: true,\n        container,\n        children\n      })\n    })\n  });\n};\nMenuPortal.displayName = PORTAL_NAME;\nvar CONTENT_NAME = \"MenuContent\";\nvar [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME);\nvar MenuContent = React.forwardRef((props, forwardedRef) => {\n  const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n  const {\n    forceMount = portalContext.forceMount,\n    ...contentProps\n  } = props;\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(Collection.Provider, {\n    scope: props.__scopeMenu,\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_presence.Presence, {\n      present: forceMount || context.open,\n      children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(Collection.Slot, {\n        scope: props.__scopeMenu,\n        children: rootContext.modal ? /* @__PURE__ */(0, import_jsx_runtime.jsx)(MenuRootContentModal, {\n          ...contentProps,\n          ref: forwardedRef\n        }) : /* @__PURE__ */(0, import_jsx_runtime.jsx)(MenuRootContentNonModal, {\n          ...contentProps,\n          ref: forwardedRef\n        })\n      })\n    })\n  });\n});\nvar MenuRootContentModal = React.forwardRef((props, forwardedRef) => {\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  const ref = React.useRef(null);\n  const composedRefs = (0, import_react_compose_refs.useComposedRefs)(forwardedRef, ref);\n  React.useEffect(() => {\n    const content = ref.current;\n    if (content) return (0, import_aria_hidden.hideOthers)(content);\n  }, []);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(MenuContentImpl, {\n    ...props,\n    ref: composedRefs,\n    trapFocus: context.open,\n    disableOutsidePointerEvents: context.open,\n    disableOutsideScroll: true,\n    onFocusOutside: (0, import_primitive.composeEventHandlers)(props.onFocusOutside, event => event.preventDefault(), {\n      checkForDefaultPrevented: false\n    }),\n    onDismiss: () => context.onOpenChange(false)\n  });\n});\nvar MenuRootContentNonModal = React.forwardRef((props, forwardedRef) => {\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(MenuContentImpl, {\n    ...props,\n    ref: forwardedRef,\n    trapFocus: false,\n    disableOutsidePointerEvents: false,\n    disableOutsideScroll: false,\n    onDismiss: () => context.onOpenChange(false)\n  });\n});\nvar MenuContentImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    loop = false,\n    trapFocus,\n    onOpenAutoFocus,\n    onCloseAutoFocus,\n    disableOutsidePointerEvents,\n    onEntryFocus,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    onFocusOutside,\n    onInteractOutside,\n    onDismiss,\n    disableOutsideScroll,\n    ...contentProps\n  } = props;\n  const context = useMenuContext(CONTENT_NAME, __scopeMenu);\n  const rootContext = useMenuRootContext(CONTENT_NAME, __scopeMenu);\n  const popperScope = usePopperScope(__scopeMenu);\n  const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n  const getItems = useCollection(__scopeMenu);\n  const [currentItemId, setCurrentItemId] = React.useState(null);\n  const contentRef = React.useRef(null);\n  const composedRefs = (0, import_react_compose_refs.useComposedRefs)(forwardedRef, contentRef, context.onContentChange);\n  const timerRef = React.useRef(0);\n  const searchRef = React.useRef(\"\");\n  const pointerGraceTimerRef = React.useRef(0);\n  const pointerGraceIntentRef = React.useRef(null);\n  const pointerDirRef = React.useRef(\"right\");\n  const lastPointerXRef = React.useRef(0);\n  const ScrollLockWrapper = disableOutsideScroll ? import_react_remove_scroll.RemoveScroll : React.Fragment;\n  const scrollLockWrapperProps = disableOutsideScroll ? {\n    as: import_react_slot.Slot,\n    allowPinchZoom: true\n  } : void 0;\n  const handleTypeaheadSearch = key => {\n    const search = searchRef.current + key;\n    const items = getItems().filter(item => !item.disabled);\n    const currentItem = document.activeElement;\n    const currentMatch = items.find(item => item.ref.current === currentItem)?.textValue;\n    const values = items.map(item => item.textValue);\n    const nextMatch = getNextMatch(values, search, currentMatch);\n    const newItem = items.find(item => item.textValue === nextMatch)?.ref.current;\n    (function updateSearch(value) {\n      searchRef.current = value;\n      window.clearTimeout(timerRef.current);\n      if (value !== \"\") timerRef.current = window.setTimeout(() => updateSearch(\"\"), 1e3);\n    })(search);\n    if (newItem) {\n      setTimeout(() => newItem.focus());\n    }\n  };\n  React.useEffect(() => {\n    return () => window.clearTimeout(timerRef.current);\n  }, []);\n  (0, import_react_focus_guards.useFocusGuards)();\n  const isPointerMovingToSubmenu = React.useCallback(event => {\n    const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;\n    return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);\n  }, []);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(MenuContentProvider, {\n    scope: __scopeMenu,\n    searchRef,\n    onItemEnter: React.useCallback(event => {\n      if (isPointerMovingToSubmenu(event)) event.preventDefault();\n    }, [isPointerMovingToSubmenu]),\n    onItemLeave: React.useCallback(event => {\n      if (isPointerMovingToSubmenu(event)) return;\n      contentRef.current?.focus();\n      setCurrentItemId(null);\n    }, [isPointerMovingToSubmenu]),\n    onTriggerLeave: React.useCallback(event => {\n      if (isPointerMovingToSubmenu(event)) event.preventDefault();\n    }, [isPointerMovingToSubmenu]),\n    pointerGraceTimerRef,\n    onPointerGraceIntentChange: React.useCallback(intent => {\n      pointerGraceIntentRef.current = intent;\n    }, []),\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(ScrollLockWrapper, {\n      ...scrollLockWrapperProps,\n      children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_focus_scope.FocusScope, {\n        asChild: true,\n        trapped: trapFocus,\n        onMountAutoFocus: (0, import_primitive.composeEventHandlers)(onOpenAutoFocus, event => {\n          event.preventDefault();\n          contentRef.current?.focus({\n            preventScroll: true\n          });\n        }),\n        onUnmountAutoFocus: onCloseAutoFocus,\n        children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_dismissable_layer.DismissableLayer, {\n          asChild: true,\n          disableOutsidePointerEvents,\n          onEscapeKeyDown,\n          onPointerDownOutside,\n          onFocusOutside,\n          onInteractOutside,\n          onDismiss,\n          children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(RovingFocusGroup.Root, {\n            asChild: true,\n            ...rovingFocusGroupScope,\n            dir: rootContext.dir,\n            orientation: \"vertical\",\n            loop,\n            currentTabStopId: currentItemId,\n            onCurrentTabStopIdChange: setCurrentItemId,\n            onEntryFocus: (0, import_primitive.composeEventHandlers)(onEntryFocus, event => {\n              if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();\n            }),\n            preventScrollOnEntryFocus: true,\n            children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(PopperPrimitive.Content, {\n              role: \"menu\",\n              \"aria-orientation\": \"vertical\",\n              \"data-state\": getOpenState(context.open),\n              \"data-radix-menu-content\": \"\",\n              dir: rootContext.dir,\n              ...popperScope,\n              ...contentProps,\n              ref: composedRefs,\n              style: {\n                outline: \"none\",\n                ...contentProps.style\n              },\n              onKeyDown: (0, import_primitive.composeEventHandlers)(contentProps.onKeyDown, event => {\n                const target = event.target;\n                const isKeyDownInside = target.closest(\"[data-radix-menu-content]\") === event.currentTarget;\n                const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n                const isCharacterKey = event.key.length === 1;\n                if (isKeyDownInside) {\n                  if (event.key === \"Tab\") event.preventDefault();\n                  if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);\n                }\n                const content = contentRef.current;\n                if (event.target !== content) return;\n                if (!FIRST_LAST_KEYS.includes(event.key)) return;\n                event.preventDefault();\n                const items = getItems().filter(item => !item.disabled);\n                const candidateNodes = items.map(item => item.ref.current);\n                if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();\n                focusFirst(candidateNodes);\n              }),\n              onBlur: (0, import_primitive.composeEventHandlers)(props.onBlur, event => {\n                if (!event.currentTarget.contains(event.target)) {\n                  window.clearTimeout(timerRef.current);\n                  searchRef.current = \"\";\n                }\n              }),\n              onPointerMove: (0, import_primitive.composeEventHandlers)(props.onPointerMove, whenMouse(event => {\n                const target = event.target;\n                const pointerXHasChanged = lastPointerXRef.current !== event.clientX;\n                if (event.currentTarget.contains(target) && pointerXHasChanged) {\n                  const newDir = event.clientX > lastPointerXRef.current ? \"right\" : \"left\";\n                  pointerDirRef.current = newDir;\n                  lastPointerXRef.current = event.clientX;\n                }\n              }))\n            })\n          })\n        })\n      })\n    })\n  });\n});\nMenuContent.displayName = CONTENT_NAME;\nvar GROUP_NAME = \"MenuGroup\";\nvar MenuGroup = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    ...groupProps\n  } = props;\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_primitive.Primitive.div, {\n    role: \"group\",\n    ...groupProps,\n    ref: forwardedRef\n  });\n});\nMenuGroup.displayName = GROUP_NAME;\nvar LABEL_NAME = \"MenuLabel\";\nvar MenuLabel = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    ...labelProps\n  } = props;\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_primitive.Primitive.div, {\n    ...labelProps,\n    ref: forwardedRef\n  });\n});\nMenuLabel.displayName = LABEL_NAME;\nvar ITEM_NAME = \"MenuItem\";\nvar ITEM_SELECT = \"menu.itemSelect\";\nvar MenuItem = React.forwardRef((props, forwardedRef) => {\n  const {\n    disabled = false,\n    onSelect,\n    ...itemProps\n  } = props;\n  const ref = React.useRef(null);\n  const rootContext = useMenuRootContext(ITEM_NAME, props.__scopeMenu);\n  const contentContext = useMenuContentContext(ITEM_NAME, props.__scopeMenu);\n  const composedRefs = (0, import_react_compose_refs.useComposedRefs)(forwardedRef, ref);\n  const isPointerDownRef = React.useRef(false);\n  const handleSelect = () => {\n    const menuItem = ref.current;\n    if (!disabled && menuItem) {\n      const itemSelectEvent = new CustomEvent(ITEM_SELECT, {\n        bubbles: true,\n        cancelable: true\n      });\n      menuItem.addEventListener(ITEM_SELECT, event => onSelect?.(event), {\n        once: true\n      });\n      (0, import_react_primitive.dispatchDiscreteCustomEvent)(menuItem, itemSelectEvent);\n      if (itemSelectEvent.defaultPrevented) {\n        isPointerDownRef.current = false;\n      } else {\n        rootContext.onClose();\n      }\n    }\n  };\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(MenuItemImpl, {\n    ...itemProps,\n    ref: composedRefs,\n    disabled,\n    onClick: (0, import_primitive.composeEventHandlers)(props.onClick, handleSelect),\n    onPointerDown: event => {\n      props.onPointerDown?.(event);\n      isPointerDownRef.current = true;\n    },\n    onPointerUp: (0, import_primitive.composeEventHandlers)(props.onPointerUp, event => {\n      if (!isPointerDownRef.current) event.currentTarget?.click();\n    }),\n    onKeyDown: (0, import_primitive.composeEventHandlers)(props.onKeyDown, event => {\n      const isTypingAhead = contentContext.searchRef.current !== \"\";\n      if (disabled || isTypingAhead && event.key === \" \") return;\n      if (SELECTION_KEYS.includes(event.key)) {\n        event.currentTarget.click();\n        event.preventDefault();\n      }\n    })\n  });\n});\nMenuItem.displayName = ITEM_NAME;\nvar MenuItemImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    disabled = false,\n    textValue,\n    ...itemProps\n  } = props;\n  const contentContext = useMenuContentContext(ITEM_NAME, __scopeMenu);\n  const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n  const ref = React.useRef(null);\n  const composedRefs = (0, import_react_compose_refs.useComposedRefs)(forwardedRef, ref);\n  const [isFocused, setIsFocused] = React.useState(false);\n  const [textContent, setTextContent] = React.useState(\"\");\n  React.useEffect(() => {\n    const menuItem = ref.current;\n    if (menuItem) {\n      setTextContent((menuItem.textContent ?? \"\").trim());\n    }\n  }, [itemProps.children]);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(Collection.ItemSlot, {\n    scope: __scopeMenu,\n    disabled,\n    textValue: textValue ?? textContent,\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(RovingFocusGroup.Item, {\n      asChild: true,\n      ...rovingFocusGroupScope,\n      focusable: !disabled,\n      children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_primitive.Primitive.div, {\n        role: \"menuitem\",\n        \"data-highlighted\": isFocused ? \"\" : void 0,\n        \"aria-disabled\": disabled || void 0,\n        \"data-disabled\": disabled ? \"\" : void 0,\n        ...itemProps,\n        ref: composedRefs,\n        onPointerMove: (0, import_primitive.composeEventHandlers)(props.onPointerMove, whenMouse(event => {\n          if (disabled) {\n            contentContext.onItemLeave(event);\n          } else {\n            contentContext.onItemEnter(event);\n            if (!event.defaultPrevented) {\n              const item = event.currentTarget;\n              item.focus({\n                preventScroll: true\n              });\n            }\n          }\n        })),\n        onPointerLeave: (0, import_primitive.composeEventHandlers)(props.onPointerLeave, whenMouse(event => contentContext.onItemLeave(event))),\n        onFocus: (0, import_primitive.composeEventHandlers)(props.onFocus, () => setIsFocused(true)),\n        onBlur: (0, import_primitive.composeEventHandlers)(props.onBlur, () => setIsFocused(false))\n      })\n    })\n  });\n});\nvar CHECKBOX_ITEM_NAME = \"MenuCheckboxItem\";\nvar MenuCheckboxItem = React.forwardRef((props, forwardedRef) => {\n  const {\n    checked = false,\n    onCheckedChange,\n    ...checkboxItemProps\n  } = props;\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(ItemIndicatorProvider, {\n    scope: props.__scopeMenu,\n    checked,\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(MenuItem, {\n      role: \"menuitemcheckbox\",\n      \"aria-checked\": isIndeterminate(checked) ? \"mixed\" : checked,\n      ...checkboxItemProps,\n      ref: forwardedRef,\n      \"data-state\": getCheckedState(checked),\n      onSelect: (0, import_primitive.composeEventHandlers)(checkboxItemProps.onSelect, () => onCheckedChange?.(isIndeterminate(checked) ? true : !checked), {\n        checkForDefaultPrevented: false\n      })\n    })\n  });\n});\nMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\nvar RADIO_GROUP_NAME = \"MenuRadioGroup\";\nvar [RadioGroupProvider, useRadioGroupContext] = createMenuContext(RADIO_GROUP_NAME, {\n  value: void 0,\n  onValueChange: () => {}\n});\nvar MenuRadioGroup = React.forwardRef((props, forwardedRef) => {\n  const {\n    value,\n    onValueChange,\n    ...groupProps\n  } = props;\n  const handleValueChange = (0, import_react_use_callback_ref.useCallbackRef)(onValueChange);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(RadioGroupProvider, {\n    scope: props.__scopeMenu,\n    value,\n    onValueChange: handleValueChange,\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(MenuGroup, {\n      ...groupProps,\n      ref: forwardedRef\n    })\n  });\n});\nMenuRadioGroup.displayName = RADIO_GROUP_NAME;\nvar RADIO_ITEM_NAME = \"MenuRadioItem\";\nvar MenuRadioItem = React.forwardRef((props, forwardedRef) => {\n  const {\n    value,\n    ...radioItemProps\n  } = props;\n  const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);\n  const checked = value === context.value;\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(ItemIndicatorProvider, {\n    scope: props.__scopeMenu,\n    checked,\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(MenuItem, {\n      role: \"menuitemradio\",\n      \"aria-checked\": checked,\n      ...radioItemProps,\n      ref: forwardedRef,\n      \"data-state\": getCheckedState(checked),\n      onSelect: (0, import_primitive.composeEventHandlers)(radioItemProps.onSelect, () => context.onValueChange?.(value), {\n        checkForDefaultPrevented: false\n      })\n    })\n  });\n});\nMenuRadioItem.displayName = RADIO_ITEM_NAME;\nvar ITEM_INDICATOR_NAME = \"MenuItemIndicator\";\nvar [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(ITEM_INDICATOR_NAME, {\n  checked: false\n});\nvar MenuItemIndicator = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    forceMount,\n    ...itemIndicatorProps\n  } = props;\n  const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_presence.Presence, {\n    present: forceMount || isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true,\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_primitive.Primitive.span, {\n      ...itemIndicatorProps,\n      ref: forwardedRef,\n      \"data-state\": getCheckedState(indicatorContext.checked)\n    })\n  });\n});\nMenuItemIndicator.displayName = ITEM_INDICATOR_NAME;\nvar SEPARATOR_NAME = \"MenuSeparator\";\nvar MenuSeparator = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    ...separatorProps\n  } = props;\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_primitive.Primitive.div, {\n    role: \"separator\",\n    \"aria-orientation\": \"horizontal\",\n    ...separatorProps,\n    ref: forwardedRef\n  });\n});\nMenuSeparator.displayName = SEPARATOR_NAME;\nvar ARROW_NAME = \"MenuArrow\";\nvar MenuArrow = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    ...arrowProps\n  } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(PopperPrimitive.Arrow, {\n    ...popperScope,\n    ...arrowProps,\n    ref: forwardedRef\n  });\n});\nMenuArrow.displayName = ARROW_NAME;\nvar SUB_NAME = \"MenuSub\";\nvar [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME);\nvar MenuSub = props => {\n  const {\n    __scopeMenu,\n    children,\n    open = false,\n    onOpenChange\n  } = props;\n  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);\n  const popperScope = usePopperScope(__scopeMenu);\n  const [trigger, setTrigger] = React.useState(null);\n  const [content, setContent] = React.useState(null);\n  const handleOpenChange = (0, import_react_use_callback_ref.useCallbackRef)(onOpenChange);\n  React.useEffect(() => {\n    if (parentMenuContext.open === false) handleOpenChange(false);\n    return () => handleOpenChange(false);\n  }, [parentMenuContext.open, handleOpenChange]);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(PopperPrimitive.Root, {\n    ...popperScope,\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(MenuProvider, {\n      scope: __scopeMenu,\n      open,\n      onOpenChange: handleOpenChange,\n      content,\n      onContentChange: setContent,\n      children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(MenuSubProvider, {\n        scope: __scopeMenu,\n        contentId: (0, import_react_id.useId)(),\n        triggerId: (0, import_react_id.useId)(),\n        trigger,\n        onTriggerChange: setTrigger,\n        children\n      })\n    })\n  });\n};\nMenuSub.displayName = SUB_NAME;\nvar SUB_TRIGGER_NAME = \"MenuSubTrigger\";\nvar MenuSubTrigger = React.forwardRef((props, forwardedRef) => {\n  const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n  const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n  const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n  const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n  const openTimerRef = React.useRef(null);\n  const {\n    pointerGraceTimerRef,\n    onPointerGraceIntentChange\n  } = contentContext;\n  const scope = {\n    __scopeMenu: props.__scopeMenu\n  };\n  const clearOpenTimer = React.useCallback(() => {\n    if (openTimerRef.current) window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = null;\n  }, []);\n  React.useEffect(() => clearOpenTimer, [clearOpenTimer]);\n  React.useEffect(() => {\n    const pointerGraceTimer = pointerGraceTimerRef.current;\n    return () => {\n      window.clearTimeout(pointerGraceTimer);\n      onPointerGraceIntentChange(null);\n    };\n  }, [pointerGraceTimerRef, onPointerGraceIntentChange]);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(MenuAnchor, {\n    asChild: true,\n    ...scope,\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(MenuItemImpl, {\n      id: subContext.triggerId,\n      \"aria-haspopup\": \"menu\",\n      \"aria-expanded\": context.open,\n      \"aria-controls\": subContext.contentId,\n      \"data-state\": getOpenState(context.open),\n      ...props,\n      ref: (0, import_react_compose_refs.composeRefs)(forwardedRef, subContext.onTriggerChange),\n      onClick: event => {\n        props.onClick?.(event);\n        if (props.disabled || event.defaultPrevented) return;\n        event.currentTarget.focus();\n        if (!context.open) context.onOpenChange(true);\n      },\n      onPointerMove: (0, import_primitive.composeEventHandlers)(props.onPointerMove, whenMouse(event => {\n        contentContext.onItemEnter(event);\n        if (event.defaultPrevented) return;\n        if (!props.disabled && !context.open && !openTimerRef.current) {\n          contentContext.onPointerGraceIntentChange(null);\n          openTimerRef.current = window.setTimeout(() => {\n            context.onOpenChange(true);\n            clearOpenTimer();\n          }, 100);\n        }\n      })),\n      onPointerLeave: (0, import_primitive.composeEventHandlers)(props.onPointerLeave, whenMouse(event => {\n        clearOpenTimer();\n        const contentRect = context.content?.getBoundingClientRect();\n        if (contentRect) {\n          const side = context.content?.dataset.side;\n          const rightSide = side === \"right\";\n          const bleed = rightSide ? -5 : 5;\n          const contentNearEdge = contentRect[rightSide ? \"left\" : \"right\"];\n          const contentFarEdge = contentRect[rightSide ? \"right\" : \"left\"];\n          contentContext.onPointerGraceIntentChange({\n            area: [\n            // Apply a bleed on clientX to ensure that our exit point is\n            // consistently within polygon bounds\n            {\n              x: event.clientX + bleed,\n              y: event.clientY\n            }, {\n              x: contentNearEdge,\n              y: contentRect.top\n            }, {\n              x: contentFarEdge,\n              y: contentRect.top\n            }, {\n              x: contentFarEdge,\n              y: contentRect.bottom\n            }, {\n              x: contentNearEdge,\n              y: contentRect.bottom\n            }],\n            side\n          });\n          window.clearTimeout(pointerGraceTimerRef.current);\n          pointerGraceTimerRef.current = window.setTimeout(() => contentContext.onPointerGraceIntentChange(null), 300);\n        } else {\n          contentContext.onTriggerLeave(event);\n          if (event.defaultPrevented) return;\n          contentContext.onPointerGraceIntentChange(null);\n        }\n      })),\n      onKeyDown: (0, import_primitive.composeEventHandlers)(props.onKeyDown, event => {\n        const isTypingAhead = contentContext.searchRef.current !== \"\";\n        if (props.disabled || isTypingAhead && event.key === \" \") return;\n        if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {\n          context.onOpenChange(true);\n          context.content?.focus();\n          event.preventDefault();\n        }\n      })\n    })\n  });\n});\nMenuSubTrigger.displayName = SUB_TRIGGER_NAME;\nvar SUB_CONTENT_NAME = \"MenuSubContent\";\nvar MenuSubContent = React.forwardRef((props, forwardedRef) => {\n  const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n  const {\n    forceMount = portalContext.forceMount,\n    ...subContentProps\n  } = props;\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n  const subContext = useMenuSubContext(SUB_CONTENT_NAME, props.__scopeMenu);\n  const ref = React.useRef(null);\n  const composedRefs = (0, import_react_compose_refs.useComposedRefs)(forwardedRef, ref);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(Collection.Provider, {\n    scope: props.__scopeMenu,\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_presence.Presence, {\n      present: forceMount || context.open,\n      children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(Collection.Slot, {\n        scope: props.__scopeMenu,\n        children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(MenuContentImpl, {\n          id: subContext.contentId,\n          \"aria-labelledby\": subContext.triggerId,\n          ...subContentProps,\n          ref: composedRefs,\n          align: \"start\",\n          side: rootContext.dir === \"rtl\" ? \"left\" : \"right\",\n          disableOutsidePointerEvents: false,\n          disableOutsideScroll: false,\n          trapFocus: false,\n          onOpenAutoFocus: event => {\n            if (rootContext.isUsingKeyboardRef.current) ref.current?.focus();\n            event.preventDefault();\n          },\n          onCloseAutoFocus: event => event.preventDefault(),\n          onFocusOutside: (0, import_primitive.composeEventHandlers)(props.onFocusOutside, event => {\n            if (event.target !== subContext.trigger) context.onOpenChange(false);\n          }),\n          onEscapeKeyDown: (0, import_primitive.composeEventHandlers)(props.onEscapeKeyDown, event => {\n            rootContext.onClose();\n            event.preventDefault();\n          }),\n          onKeyDown: (0, import_primitive.composeEventHandlers)(props.onKeyDown, event => {\n            const isKeyDownInside = event.currentTarget.contains(event.target);\n            const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);\n            if (isKeyDownInside && isCloseKey) {\n              context.onOpenChange(false);\n              subContext.trigger?.focus();\n              event.preventDefault();\n            }\n          })\n        })\n      })\n    })\n  });\n});\nMenuSubContent.displayName = SUB_CONTENT_NAME;\nfunction getOpenState(open) {\n  return open ? \"open\" : \"closed\";\n}\nfunction isIndeterminate(checked) {\n  return checked === \"indeterminate\";\n}\nfunction getCheckedState(checked) {\n  return isIndeterminate(checked) ? \"indeterminate\" : checked ? \"checked\" : \"unchecked\";\n}\nfunction focusFirst(candidates) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\nfunction wrapArray(array, startIndex) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\nfunction getNextMatch(values, search, currentMatch) {\n  const isRepeated = search.length > 1 && Array.from(search).every(char => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0] : search;\n  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;\n  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));\n  const excludeCurrentMatch = normalizedSearch.length === 1;\n  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter(v => v !== currentMatch);\n  const nextMatch = wrappedValues.find(value => value.toLowerCase().startsWith(normalizedSearch.toLowerCase()));\n  return nextMatch !== currentMatch ? nextMatch : void 0;\n}\nfunction isPointInPolygon(point, polygon) {\n  const {\n    x,\n    y\n  } = point;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) inside = !inside;\n  }\n  return inside;\n}\nfunction isPointerInGraceArea(event, area) {\n  if (!area) return false;\n  const cursorPos = {\n    x: event.clientX,\n    y: event.clientY\n  };\n  return isPointInPolygon(cursorPos, area);\n}\nfunction whenMouse(handler) {\n  return event => event.pointerType === \"mouse\" ? handler(event) : void 0;\n}\nvar Root3 = Menu;\nvar Anchor2 = MenuAnchor;\nvar Portal = MenuPortal;\nvar Content2 = MenuContent;\nvar Group = MenuGroup;\nvar Label = MenuLabel;\nvar Item2 = MenuItem;\nvar CheckboxItem = MenuCheckboxItem;\nvar RadioGroup = MenuRadioGroup;\nvar RadioItem = MenuRadioItem;\nvar ItemIndicator = MenuItemIndicator;\nvar Separator = MenuSeparator;\nvar Arrow2 = MenuArrow;\nvar Sub = MenuSub;\nvar SubTrigger = MenuSubTrigger;\nvar SubContent = MenuSubContent;","map":{"version":3,"names":["src_exports","__export","Anchor","Anchor2","Arrow","Arrow2","CheckboxItem","Content","Content2","Group","Item","Item2","ItemIndicator","Label","Menu","MenuAnchor","MenuArrow","MenuCheckboxItem","MenuContent","MenuGroup","MenuItem","MenuItemIndicator","MenuLabel","MenuPortal","MenuRadioGroup","MenuRadioItem","MenuSeparator","MenuSub","MenuSubContent","MenuSubTrigger","Portal","RadioGroup","RadioItem","Root","Root3","Separator","Sub","SubContent","SubTrigger","createMenuScope","module","exports","__toCommonJS","React","__toESM","require","import_primitive","import_react_collection","import_react_compose_refs","import_react_context","import_react_direction","import_react_dismissable_layer","import_react_focus_guards","import_react_focus_scope","import_react_id","PopperPrimitive","import_react_popper","import_react_portal","import_react_presence","import_react_primitive","RovingFocusGroup","import_react_roving_focus","import_react_slot","import_react_use_callback_ref","import_aria_hidden","import_react_remove_scroll","import_jsx_runtime","SELECTION_KEYS","FIRST_KEYS","LAST_KEYS","FIRST_LAST_KEYS","SUB_OPEN_KEYS","ltr","rtl","SUB_CLOSE_KEYS","MENU_NAME","Collection","useCollection","createCollectionScope","createCollection","createMenuContext","createContextScope","createPopperScope","createRovingFocusGroupScope","usePopperScope","useRovingFocusGroupScope","MenuProvider","useMenuContext","MenuRootProvider","useMenuRootContext","props","__scopeMenu","open","children","dir","onOpenChange","modal","popperScope","content","setContent","useState","isUsingKeyboardRef","useRef","handleOpenChange","useCallbackRef","direction","useDirection","useEffect","handleKeyDown","current","document","addEventListener","handlePointer","capture","once","removeEventListener","jsx","scope","onContentChange","onClose","useCallback","displayName","ANCHOR_NAME","forwardRef","forwardedRef","anchorProps","ref","PORTAL_NAME","PortalProvider","usePortalContext","forceMount","container","context","Presence","present","asChild","CONTENT_NAME","MenuContentProvider","useMenuContentContext","portalContext","contentProps","rootContext","Provider","Slot","MenuRootContentModal","MenuRootContentNonModal","composedRefs","useComposedRefs","hideOthers","MenuContentImpl","trapFocus","disableOutsidePointerEvents","disableOutsideScroll","onFocusOutside","composeEventHandlers","event","preventDefault","checkForDefaultPrevented","onDismiss","loop","onOpenAutoFocus","onCloseAutoFocus","onEntryFocus","onEscapeKeyDown","onPointerDownOutside","onInteractOutside","rovingFocusGroupScope","getItems","currentItemId","setCurrentItemId","contentRef","timerRef","searchRef","pointerGraceTimerRef","pointerGraceIntentRef","pointerDirRef","lastPointerXRef","ScrollLockWrapper","RemoveScroll","Fragment","scrollLockWrapperProps","as","allowPinchZoom","handleTypeaheadSearch","key","search","items","filter","item","disabled","currentItem","activeElement","currentMatch","find","textValue","values","map","nextMatch","getNextMatch","newItem","updateSearch","value","window","clearTimeout","setTimeout","focus","useFocusGuards","isPointerMovingToSubmenu","isMovingTowards","side","isPointerInGraceArea","area","onItemEnter","onItemLeave","onTriggerLeave","onPointerGraceIntentChange","intent","FocusScope","trapped","onMountAutoFocus","preventScroll","onUnmountAutoFocus","DismissableLayer","orientation","currentTabStopId","onCurrentTabStopIdChange","preventScrollOnEntryFocus","role","getOpenState","style","outline","onKeyDown","target","isKeyDownInside","closest","currentTarget","isModifierKey","ctrlKey","altKey","metaKey","isCharacterKey","length","includes","candidateNodes","reverse","focusFirst","onBlur","contains","onPointerMove","whenMouse","pointerXHasChanged","clientX","newDir","GROUP_NAME","groupProps","Primitive","div","LABEL_NAME","labelProps","ITEM_NAME","ITEM_SELECT","onSelect","itemProps","contentContext","isPointerDownRef","handleSelect","menuItem","itemSelectEvent","CustomEvent","bubbles","cancelable","dispatchDiscreteCustomEvent","defaultPrevented","MenuItemImpl","onClick","onPointerDown","onPointerUp","click","isTypingAhead","isFocused","setIsFocused","textContent","setTextContent","trim","ItemSlot","focusable","onPointerLeave","onFocus","CHECKBOX_ITEM_NAME","checked","onCheckedChange","checkboxItemProps","ItemIndicatorProvider","isIndeterminate","getCheckedState","RADIO_GROUP_NAME","RadioGroupProvider","useRadioGroupContext","onValueChange","handleValueChange","RADIO_ITEM_NAME","radioItemProps","ITEM_INDICATOR_NAME","useItemIndicatorContext","itemIndicatorProps","indicatorContext","span","SEPARATOR_NAME","separatorProps","ARROW_NAME","arrowProps","SUB_NAME","MenuSubProvider","useMenuSubContext","parentMenuContext","trigger","setTrigger","contentId","useId","triggerId","onTriggerChange","SUB_TRIGGER_NAME","subContext","openTimerRef","clearOpenTimer","pointerGraceTimer","id","composeRefs","contentRect","getBoundingClientRect","dataset","rightSide","bleed","contentNearEdge","contentFarEdge","x","y","clientY","top","bottom","SUB_CONTENT_NAME","subContentProps","align","isCloseKey","candidates","PREVIOUSLY_FOCUSED_ELEMENT","candidate","wrapArray","array","startIndex","_","index","isRepeated","Array","from","every","char","normalizedSearch","currentMatchIndex","indexOf","wrappedValues","Math","max","excludeCurrentMatch","v","toLowerCase","startsWith","isPointInPolygon","point","polygon","inside","i","j","xi","yi","xj","yj","intersect","cursorPos","handler","pointerType"],"sources":["/Users/catiecook/Documents/workos/frontend-take-home/client/node_modules/@radix-ui/react-menu/src/index.ts","/Users/catiecook/Documents/workos/frontend-take-home/client/node_modules/@radix-ui/react-menu/src/menu.tsx"],"sourcesContent":["'use client';\nexport {\n  createMenuScope,\n  //\n  Menu,\n  MenuAnchor,\n  MenuPortal,\n  MenuContent,\n  MenuGroup,\n  MenuLabel,\n  MenuItem,\n  MenuCheckboxItem,\n  MenuRadioGroup,\n  MenuRadioItem,\n  MenuItemIndicator,\n  MenuSeparator,\n  MenuArrow,\n  MenuSub,\n  MenuSubTrigger,\n  MenuSubContent,\n  //\n  Root,\n  Anchor,\n  Portal,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n  Sub,\n  SubTrigger,\n  SubContent,\n} from './menu';\nexport type {\n  MenuProps,\n  MenuAnchorProps,\n  MenuPortalProps,\n  MenuContentProps,\n  MenuGroupProps,\n  MenuLabelProps,\n  MenuItemProps,\n  MenuCheckboxItemProps,\n  MenuRadioGroupProps,\n  MenuRadioItemProps,\n  MenuItemIndicatorProps,\n  MenuSeparatorProps,\n  MenuArrowProps,\n  MenuSubProps,\n  MenuSubTriggerProps,\n  MenuSubContentProps,\n} from './menu';\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs, composeRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { useFocusGuards } from '@radix-ui/react-focus-guards';\nimport { FocusScope } from '@radix-ui/react-focus-scope';\nimport { useId } from '@radix-ui/react-id';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal as PortalPrimitive } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { Slot } from '@radix-ui/react-slot';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { hideOthers } from 'aria-hidden';\nimport { RemoveScroll } from 'react-remove-scroll';\n\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst SELECTION_KEYS = ['Enter', ' '];\nconst FIRST_KEYS = ['ArrowDown', 'PageUp', 'Home'];\nconst LAST_KEYS = ['ArrowUp', 'PageDown', 'End'];\nconst FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nconst SUB_OPEN_KEYS: Record<Direction, string[]> = {\n  ltr: [...SELECTION_KEYS, 'ArrowRight'],\n  rtl: [...SELECTION_KEYS, 'ArrowLeft'],\n};\nconst SUB_CLOSE_KEYS: Record<Direction, string[]> = {\n  ltr: ['ArrowLeft'],\n  rtl: ['ArrowRight'],\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Menu\n * -----------------------------------------------------------------------------------------------*/\n\nconst MENU_NAME = 'Menu';\n\ntype ItemData = { disabled: boolean; textValue: string };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  MenuItemElement,\n  ItemData\n>(MENU_NAME);\n\ntype ScopedProps<P> = P & { __scopeMenu?: Scope };\nconst [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [\n  createCollectionScope,\n  createPopperScope,\n  createRovingFocusGroupScope,\n]);\nconst usePopperScope = createPopperScope();\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\n\ntype MenuContextValue = {\n  open: boolean;\n  onOpenChange(open: boolean): void;\n  content: MenuContentElement | null;\n  onContentChange(content: MenuContentElement | null): void;\n};\n\nconst [MenuProvider, useMenuContext] = createMenuContext<MenuContextValue>(MENU_NAME);\n\ntype MenuRootContextValue = {\n  onClose(): void;\n  isUsingKeyboardRef: React.RefObject<boolean>;\n  dir: Direction;\n  modal: boolean;\n};\n\nconst [MenuRootProvider, useMenuRootContext] = createMenuContext<MenuRootContextValue>(MENU_NAME);\n\ninterface MenuProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n  dir?: Direction;\n  modal?: boolean;\n}\n\nconst Menu: React.FC<MenuProps> = (props: ScopedProps<MenuProps>) => {\n  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const isUsingKeyboardRef = React.useRef(false);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n  const direction = useDirection(dir);\n\n  React.useEffect(() => {\n    // Capture phase ensures we set the boolean before any side effects execute\n    // in response to the key or pointer event as they might depend on this value.\n    const handleKeyDown = () => {\n      isUsingKeyboardRef.current = true;\n      document.addEventListener('pointerdown', handlePointer, { capture: true, once: true });\n      document.addEventListener('pointermove', handlePointer, { capture: true, once: true });\n    };\n    const handlePointer = () => (isUsingKeyboardRef.current = false);\n    document.addEventListener('keydown', handleKeyDown, { capture: true });\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown, { capture: true });\n      document.removeEventListener('pointerdown', handlePointer, { capture: true });\n      document.removeEventListener('pointermove', handlePointer, { capture: true });\n    };\n  }, []);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n      >\n        <MenuRootProvider\n          scope={__scopeMenu}\n          onClose={React.useCallback(() => handleOpenChange(false), [handleOpenChange])}\n          isUsingKeyboardRef={isUsingKeyboardRef}\n          dir={direction}\n          modal={modal}\n        >\n          {children}\n        </MenuRootProvider>\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenu.displayName = MENU_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'MenuAnchor';\n\ntype MenuAnchorElement = React.ElementRef<typeof PopperPrimitive.Anchor>;\ntype PopperAnchorProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Anchor>;\ninterface MenuAnchorProps extends PopperAnchorProps {}\n\nconst MenuAnchor = React.forwardRef<MenuAnchorElement, MenuAnchorProps>(\n  (props: ScopedProps<MenuAnchorProps>, forwardedRef) => {\n    const { __scopeMenu, ...anchorProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Anchor {...popperScope} {...anchorProps} ref={forwardedRef} />;\n  }\n);\n\nMenuAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'MenuPortal';\n\ntype PortalContextValue = { forceMount?: true };\nconst [PortalProvider, usePortalContext] = createMenuContext<PortalContextValue>(PORTAL_NAME, {\n  forceMount: undefined,\n});\n\ntype PortalProps = React.ComponentPropsWithoutRef<typeof PortalPrimitive>;\ninterface MenuPortalProps {\n  children?: React.ReactNode;\n  /**\n   * Specify a container element to portal the content into.\n   */\n  container?: PortalProps['container'];\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuPortal: React.FC<MenuPortalProps> = (props: ScopedProps<MenuPortalProps>) => {\n  const { __scopeMenu, forceMount, children, container } = props;\n  const context = useMenuContext(PORTAL_NAME, __scopeMenu);\n  return (\n    <PortalProvider scope={__scopeMenu} forceMount={forceMount}>\n      <Presence present={forceMount || context.open}>\n        <PortalPrimitive asChild container={container}>\n          {children}\n        </PortalPrimitive>\n      </Presence>\n    </PortalProvider>\n  );\n};\n\nMenuPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'MenuContent';\n\ntype MenuContentContextValue = {\n  onItemEnter(event: React.PointerEvent): void;\n  onItemLeave(event: React.PointerEvent): void;\n  onTriggerLeave(event: React.PointerEvent): void;\n  searchRef: React.RefObject<string>;\n  pointerGraceTimerRef: React.MutableRefObject<number>;\n  onPointerGraceIntentChange(intent: GraceIntent | null): void;\n};\nconst [MenuContentProvider, useMenuContentContext] =\n  createMenuContext<MenuContentContextValue>(CONTENT_NAME);\n\ntype MenuContentElement = MenuRootContentTypeElement;\n/**\n * We purposefully don't union MenuRootContent and MenuSubContent props here because\n * they have conflicting prop types. We agreed that we would allow MenuSubContent to\n * accept props that it would just ignore.\n */\ninterface MenuContentProps extends MenuRootContentTypeProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuContent = React.forwardRef<MenuContentElement, MenuContentProps>(\n  (props: ScopedProps<MenuContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n    const { forceMount = portalContext.forceMount, ...contentProps } = props;\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n\n    return (\n      <Collection.Provider scope={props.__scopeMenu}>\n        <Presence present={forceMount || context.open}>\n          <Collection.Slot scope={props.__scopeMenu}>\n            {rootContext.modal ? (\n              <MenuRootContentModal {...contentProps} ref={forwardedRef} />\n            ) : (\n              <MenuRootContentNonModal {...contentProps} ref={forwardedRef} />\n            )}\n          </Collection.Slot>\n        </Presence>\n      </Collection.Provider>\n    );\n  }\n);\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuRootContentTypeElement = MenuContentImplElement;\ninterface MenuRootContentTypeProps\n  extends Omit<MenuContentImplProps, keyof MenuContentImplPrivateProps> {}\n\nconst MenuRootContentModal = React.forwardRef<MenuRootContentTypeElement, MenuRootContentTypeProps>(\n  (props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuRootContentTypeElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    // Hide everything from ARIA except the `MenuContent`\n    React.useEffect(() => {\n      const content = ref.current;\n      if (content) return hideOthers(content);\n    }, []);\n\n    return (\n      <MenuContentImpl\n        {...props}\n        ref={composedRefs}\n        // we make sure we're not trapping once it's been closed\n        // (closed !== unmounted when animating out)\n        trapFocus={context.open}\n        // make sure to only disable pointer events when open\n        // this avoids blocking interactions while animating out\n        disableOutsidePointerEvents={context.open}\n        disableOutsideScroll\n        // When focus is trapped, a `focusout` event may still happen.\n        // We make sure we don't trigger our `onDismiss` in such case.\n        onFocusOutside={composeEventHandlers(\n          props.onFocusOutside,\n          (event) => event.preventDefault(),\n          { checkForDefaultPrevented: false }\n        )}\n        onDismiss={() => context.onOpenChange(false)}\n      />\n    );\n  }\n);\n\nconst MenuRootContentNonModal = React.forwardRef<\n  MenuRootContentTypeElement,\n  MenuRootContentTypeProps\n>((props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  return (\n    <MenuContentImpl\n      {...props}\n      ref={forwardedRef}\n      trapFocus={false}\n      disableOutsidePointerEvents={false}\n      disableOutsideScroll={false}\n      onDismiss={() => context.onOpenChange(false)}\n    />\n  );\n});\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuContentImplElement = React.ElementRef<typeof PopperPrimitive.Content>;\ntype FocusScopeProps = React.ComponentPropsWithoutRef<typeof FocusScope>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype RovingFocusGroupProps = React.ComponentPropsWithoutRef<typeof RovingFocusGroup.Root>;\ntype PopperContentProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ntype MenuContentImplPrivateProps = {\n  onOpenAutoFocus?: FocusScopeProps['onMountAutoFocus'];\n  onDismiss?: DismissableLayerProps['onDismiss'];\n  disableOutsidePointerEvents?: DismissableLayerProps['disableOutsidePointerEvents'];\n\n  /**\n   * Whether scrolling outside the `MenuContent` should be prevented\n   * (default: `false`)\n   */\n  disableOutsideScroll?: boolean;\n\n  /**\n   * Whether focus should be trapped within the `MenuContent`\n   * (default: false)\n   */\n  trapFocus?: FocusScopeProps['trapped'];\n};\ninterface MenuContentImplProps\n  extends MenuContentImplPrivateProps,\n    Omit<PopperContentProps, 'dir' | 'onPlaced'> {\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  onCloseAutoFocus?: FocusScopeProps['onUnmountAutoFocus'];\n\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: RovingFocusGroupProps['loop'];\n\n  onEntryFocus?: RovingFocusGroupProps['onEntryFocus'];\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  onPointerDownOutside?: DismissableLayerProps['onPointerDownOutside'];\n  onFocusOutside?: DismissableLayerProps['onFocusOutside'];\n  onInteractOutside?: DismissableLayerProps['onInteractOutside'];\n}\n\nconst MenuContentImpl = React.forwardRef<MenuContentImplElement, MenuContentImplProps>(\n  (props: ScopedProps<MenuContentImplProps>, forwardedRef) => {\n    const {\n      __scopeMenu,\n      loop = false,\n      trapFocus,\n      onOpenAutoFocus,\n      onCloseAutoFocus,\n      disableOutsidePointerEvents,\n      onEntryFocus,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      disableOutsideScroll,\n      ...contentProps\n    } = props;\n    const context = useMenuContext(CONTENT_NAME, __scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, __scopeMenu);\n    const popperScope = usePopperScope(__scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const getItems = useCollection(__scopeMenu);\n    const [currentItemId, setCurrentItemId] = React.useState<string | null>(null);\n    const contentRef = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);\n    const timerRef = React.useRef(0);\n    const searchRef = React.useRef('');\n    const pointerGraceTimerRef = React.useRef(0);\n    const pointerGraceIntentRef = React.useRef<GraceIntent | null>(null);\n    const pointerDirRef = React.useRef<Side>('right');\n    const lastPointerXRef = React.useRef(0);\n\n    const ScrollLockWrapper = disableOutsideScroll ? RemoveScroll : React.Fragment;\n    const scrollLockWrapperProps = disableOutsideScroll\n      ? { as: Slot, allowPinchZoom: true }\n      : undefined;\n\n    const handleTypeaheadSearch = (key: string) => {\n      const search = searchRef.current + key;\n      const items = getItems().filter((item) => !item.disabled);\n      const currentItem = document.activeElement;\n      const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;\n      const values = items.map((item) => item.textValue);\n      const nextMatch = getNextMatch(values, search, currentMatch);\n      const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;\n\n      // Reset `searchRef` 1 second after it was last updated\n      (function updateSearch(value: string) {\n        searchRef.current = value;\n        window.clearTimeout(timerRef.current);\n        if (value !== '') timerRef.current = window.setTimeout(() => updateSearch(''), 1000);\n      })(search);\n\n      if (newItem) {\n        /**\n         * Imperative focus during keydown is risky so we prevent React's batching updates\n         * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n         */\n        setTimeout(() => (newItem as HTMLElement).focus());\n      }\n    };\n\n    React.useEffect(() => {\n      return () => window.clearTimeout(timerRef.current);\n    }, []);\n\n    // Make sure the whole tree has focus guards as our `MenuContent` may be\n    // the last element in the DOM (because of the `Portal`)\n    useFocusGuards();\n\n    const isPointerMovingToSubmenu = React.useCallback((event: React.PointerEvent) => {\n      const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;\n      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);\n    }, []);\n\n    return (\n      <MenuContentProvider\n        scope={__scopeMenu}\n        searchRef={searchRef}\n        onItemEnter={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) event.preventDefault();\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        onItemLeave={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) return;\n            contentRef.current?.focus();\n            setCurrentItemId(null);\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        onTriggerLeave={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) event.preventDefault();\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        pointerGraceTimerRef={pointerGraceTimerRef}\n        onPointerGraceIntentChange={React.useCallback((intent) => {\n          pointerGraceIntentRef.current = intent;\n        }, [])}\n      >\n        <ScrollLockWrapper {...scrollLockWrapperProps}>\n          <FocusScope\n            asChild\n            trapped={trapFocus}\n            onMountAutoFocus={composeEventHandlers(onOpenAutoFocus, (event) => {\n              // when opening, explicitly focus the content area only and leave\n              // `onEntryFocus` in  control of focusing first item\n              event.preventDefault();\n              contentRef.current?.focus({ preventScroll: true });\n            })}\n            onUnmountAutoFocus={onCloseAutoFocus}\n          >\n            <DismissableLayer\n              asChild\n              disableOutsidePointerEvents={disableOutsidePointerEvents}\n              onEscapeKeyDown={onEscapeKeyDown}\n              onPointerDownOutside={onPointerDownOutside}\n              onFocusOutside={onFocusOutside}\n              onInteractOutside={onInteractOutside}\n              onDismiss={onDismiss}\n            >\n              <RovingFocusGroup.Root\n                asChild\n                {...rovingFocusGroupScope}\n                dir={rootContext.dir}\n                orientation=\"vertical\"\n                loop={loop}\n                currentTabStopId={currentItemId}\n                onCurrentTabStopIdChange={setCurrentItemId}\n                onEntryFocus={composeEventHandlers(onEntryFocus, (event) => {\n                  // only focus first item when using keyboard\n                  if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();\n                })}\n                preventScrollOnEntryFocus\n              >\n                <PopperPrimitive.Content\n                  role=\"menu\"\n                  aria-orientation=\"vertical\"\n                  data-state={getOpenState(context.open)}\n                  data-radix-menu-content=\"\"\n                  dir={rootContext.dir}\n                  {...popperScope}\n                  {...contentProps}\n                  ref={composedRefs}\n                  style={{ outline: 'none', ...contentProps.style }}\n                  onKeyDown={composeEventHandlers(contentProps.onKeyDown, (event) => {\n                    // submenu key events bubble through portals. We only care about keys in this menu.\n                    const target = event.target as HTMLElement;\n                    const isKeyDownInside =\n                      target.closest('[data-radix-menu-content]') === event.currentTarget;\n                    const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n                    const isCharacterKey = event.key.length === 1;\n                    if (isKeyDownInside) {\n                      // menus should not be navigated using tab key so we prevent it\n                      if (event.key === 'Tab') event.preventDefault();\n                      if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);\n                    }\n                    // focus first/last item based on key pressed\n                    const content = contentRef.current;\n                    if (event.target !== content) return;\n                    if (!FIRST_LAST_KEYS.includes(event.key)) return;\n                    event.preventDefault();\n                    const items = getItems().filter((item) => !item.disabled);\n                    const candidateNodes = items.map((item) => item.ref.current!);\n                    if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();\n                    focusFirst(candidateNodes);\n                  })}\n                  onBlur={composeEventHandlers(props.onBlur, (event) => {\n                    // clear search buffer when leaving the menu\n                    if (!event.currentTarget.contains(event.target)) {\n                      window.clearTimeout(timerRef.current);\n                      searchRef.current = '';\n                    }\n                  })}\n                  onPointerMove={composeEventHandlers(\n                    props.onPointerMove,\n                    whenMouse((event) => {\n                      const target = event.target as HTMLElement;\n                      const pointerXHasChanged = lastPointerXRef.current !== event.clientX;\n\n                      // We don't use `event.movementX` for this check because Safari will\n                      // always return `0` on a pointer event.\n                      if (event.currentTarget.contains(target) && pointerXHasChanged) {\n                        const newDir = event.clientX > lastPointerXRef.current ? 'right' : 'left';\n                        pointerDirRef.current = newDir;\n                        lastPointerXRef.current = event.clientX;\n                      }\n                    })\n                  )}\n                />\n              </RovingFocusGroup.Root>\n            </DismissableLayer>\n          </FocusScope>\n        </ScrollLockWrapper>\n      </MenuContentProvider>\n    );\n  }\n);\n\nMenuContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'MenuGroup';\n\ntype MenuGroupElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface MenuGroupProps extends PrimitiveDivProps {}\n\nconst MenuGroup = React.forwardRef<MenuGroupElement, MenuGroupProps>(\n  (props: ScopedProps<MenuGroupProps>, forwardedRef) => {\n    const { __scopeMenu, ...groupProps } = props;\n    return <Primitive.div role=\"group\" {...groupProps} ref={forwardedRef} />;\n  }\n);\n\nMenuGroup.displayName = GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuLabel\n * -----------------------------------------------------------------------------------------------*/\n\nconst LABEL_NAME = 'MenuLabel';\n\ntype MenuLabelElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuLabelProps extends PrimitiveDivProps {}\n\nconst MenuLabel = React.forwardRef<MenuLabelElement, MenuLabelProps>(\n  (props: ScopedProps<MenuLabelProps>, forwardedRef) => {\n    const { __scopeMenu, ...labelProps } = props;\n    return <Primitive.div {...labelProps} ref={forwardedRef} />;\n  }\n);\n\nMenuLabel.displayName = LABEL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'MenuItem';\nconst ITEM_SELECT = 'menu.itemSelect';\n\ntype MenuItemElement = MenuItemImplElement;\ninterface MenuItemProps extends Omit<MenuItemImplProps, 'onSelect'> {\n  onSelect?: (event: Event) => void;\n}\n\nconst MenuItem = React.forwardRef<MenuItemElement, MenuItemProps>(\n  (props: ScopedProps<MenuItemProps>, forwardedRef) => {\n    const { disabled = false, onSelect, ...itemProps } = props;\n    const ref = React.useRef<HTMLDivElement>(null);\n    const rootContext = useMenuRootContext(ITEM_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(ITEM_NAME, props.__scopeMenu);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const isPointerDownRef = React.useRef(false);\n\n    const handleSelect = () => {\n      const menuItem = ref.current;\n      if (!disabled && menuItem) {\n        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });\n        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), { once: true });\n        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);\n        if (itemSelectEvent.defaultPrevented) {\n          isPointerDownRef.current = false;\n        } else {\n          rootContext.onClose();\n        }\n      }\n    };\n\n    return (\n      <MenuItemImpl\n        {...itemProps}\n        ref={composedRefs}\n        disabled={disabled}\n        onClick={composeEventHandlers(props.onClick, handleSelect)}\n        onPointerDown={(event) => {\n          props.onPointerDown?.(event);\n          isPointerDownRef.current = true;\n        }}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          // Pointer down can move to a different menu item which should activate it on pointer up.\n          // We dispatch a click for selection to allow composition with click based triggers and to\n          // prevent Firefox from getting stuck in text selection mode when the menu closes.\n          if (!isPointerDownRef.current) event.currentTarget?.click();\n        })}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          const isTypingAhead = contentContext.searchRef.current !== '';\n          if (disabled || (isTypingAhead && event.key === ' ')) return;\n          if (SELECTION_KEYS.includes(event.key)) {\n            event.currentTarget.click();\n            /**\n             * We prevent default browser behaviour for selection keys as they should trigger\n             * a selection only:\n             * - prevents space from scrolling the page.\n             * - if keydown causes focus to move, prevents keydown from firing on the new target.\n             */\n            event.preventDefault();\n          }\n        })}\n      />\n    );\n  }\n);\n\nMenuItem.displayName = ITEM_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuItemImplElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuItemImplProps extends PrimitiveDivProps {\n  disabled?: boolean;\n  textValue?: string;\n}\n\nconst MenuItemImpl = React.forwardRef<MenuItemImplElement, MenuItemImplProps>(\n  (props: ScopedProps<MenuItemImplProps>, forwardedRef) => {\n    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;\n    const contentContext = useMenuContentContext(ITEM_NAME, __scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const ref = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const [isFocused, setIsFocused] = React.useState(false);\n\n    // get the item's `.textContent` as default strategy for typeahead `textValue`\n    const [textContent, setTextContent] = React.useState('');\n    React.useEffect(() => {\n      const menuItem = ref.current;\n      if (menuItem) {\n        setTextContent((menuItem.textContent ?? '').trim());\n      }\n    }, [itemProps.children]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeMenu}\n        disabled={disabled}\n        textValue={textValue ?? textContent}\n      >\n        <RovingFocusGroup.Item asChild {...rovingFocusGroupScope} focusable={!disabled}>\n          <Primitive.div\n            role=\"menuitem\"\n            data-highlighted={isFocused ? '' : undefined}\n            aria-disabled={disabled || undefined}\n            data-disabled={disabled ? '' : undefined}\n            {...itemProps}\n            ref={composedRefs}\n            /**\n             * We focus items on `pointerMove` to achieve the following:\n             *\n             * - Mouse over an item (it focuses)\n             * - Leave mouse where it is and use keyboard to focus a different item\n             * - Wiggle mouse without it leaving previously focused item\n             * - Previously focused item should re-focus\n             *\n             * If we used `mouseOver`/`mouseEnter` it would not re-focus when the mouse\n             * wiggles. This is to match native menu implementation.\n             */\n            onPointerMove={composeEventHandlers(\n              props.onPointerMove,\n              whenMouse((event) => {\n                if (disabled) {\n                  contentContext.onItemLeave(event);\n                } else {\n                  contentContext.onItemEnter(event);\n                  if (!event.defaultPrevented) {\n                    const item = event.currentTarget;\n                    item.focus({ preventScroll: true });\n                  }\n                }\n              })\n            )}\n            onPointerLeave={composeEventHandlers(\n              props.onPointerLeave,\n              whenMouse((event) => contentContext.onItemLeave(event))\n            )}\n            onFocus={composeEventHandlers(props.onFocus, () => setIsFocused(true))}\n            onBlur={composeEventHandlers(props.onBlur, () => setIsFocused(false))}\n          />\n        </RovingFocusGroup.Item>\n      </Collection.ItemSlot>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * MenuCheckboxItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_ITEM_NAME = 'MenuCheckboxItem';\n\ntype MenuCheckboxItemElement = MenuItemElement;\n\ntype CheckedState = boolean | 'indeterminate';\n\ninterface MenuCheckboxItemProps extends MenuItemProps {\n  checked?: CheckedState;\n  // `onCheckedChange` can never be called with `\"indeterminate\"` from the inside\n  onCheckedChange?: (checked: boolean) => void;\n}\n\nconst MenuCheckboxItem = React.forwardRef<MenuCheckboxItemElement, MenuCheckboxItemProps>(\n  (props: ScopedProps<MenuCheckboxItemProps>, forwardedRef) => {\n    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemcheckbox\"\n          aria-checked={isIndeterminate(checked) ? 'mixed' : checked}\n          {...checkboxItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            checkboxItemProps.onSelect,\n            () => onCheckedChange?.(isIndeterminate(checked) ? true : !checked),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_GROUP_NAME = 'MenuRadioGroup';\n\nconst [RadioGroupProvider, useRadioGroupContext] = createMenuContext<MenuRadioGroupProps>(\n  RADIO_GROUP_NAME,\n  { value: undefined, onValueChange: () => {} }\n);\n\ntype MenuRadioGroupElement = React.ElementRef<typeof MenuGroup>;\ninterface MenuRadioGroupProps extends MenuGroupProps {\n  value?: string;\n  onValueChange?: (value: string) => void;\n}\n\nconst MenuRadioGroup = React.forwardRef<MenuRadioGroupElement, MenuRadioGroupProps>(\n  (props: ScopedProps<MenuRadioGroupProps>, forwardedRef) => {\n    const { value, onValueChange, ...groupProps } = props;\n    const handleValueChange = useCallbackRef(onValueChange);\n    return (\n      <RadioGroupProvider scope={props.__scopeMenu} value={value} onValueChange={handleValueChange}>\n        <MenuGroup {...groupProps} ref={forwardedRef} />\n      </RadioGroupProvider>\n    );\n  }\n);\n\nMenuRadioGroup.displayName = RADIO_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_ITEM_NAME = 'MenuRadioItem';\n\ntype MenuRadioItemElement = React.ElementRef<typeof MenuItem>;\ninterface MenuRadioItemProps extends MenuItemProps {\n  value: string;\n}\n\nconst MenuRadioItem = React.forwardRef<MenuRadioItemElement, MenuRadioItemProps>(\n  (props: ScopedProps<MenuRadioItemProps>, forwardedRef) => {\n    const { value, ...radioItemProps } = props;\n    const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);\n    const checked = value === context.value;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemradio\"\n          aria-checked={checked}\n          {...radioItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            radioItemProps.onSelect,\n            () => context.onValueChange?.(value),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuRadioItem.displayName = RADIO_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_INDICATOR_NAME = 'MenuItemIndicator';\n\ntype CheckboxContextValue = { checked: CheckedState };\n\nconst [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext<CheckboxContextValue>(\n  ITEM_INDICATOR_NAME,\n  { checked: false }\n);\n\ntype MenuItemIndicatorElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface MenuItemIndicatorProps extends PrimitiveSpanProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuItemIndicator = React.forwardRef<MenuItemIndicatorElement, MenuItemIndicatorProps>(\n  (props: ScopedProps<MenuItemIndicatorProps>, forwardedRef) => {\n    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;\n    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);\n    return (\n      <Presence\n        present={\n          forceMount ||\n          isIndeterminate(indicatorContext.checked) ||\n          indicatorContext.checked === true\n        }\n      >\n        <Primitive.span\n          {...itemIndicatorProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(indicatorContext.checked)}\n        />\n      </Presence>\n    );\n  }\n);\n\nMenuItemIndicator.displayName = ITEM_INDICATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSeparator\n * -----------------------------------------------------------------------------------------------*/\n\nconst SEPARATOR_NAME = 'MenuSeparator';\n\ntype MenuSeparatorElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuSeparatorProps extends PrimitiveDivProps {}\n\nconst MenuSeparator = React.forwardRef<MenuSeparatorElement, MenuSeparatorProps>(\n  (props: ScopedProps<MenuSeparatorProps>, forwardedRef) => {\n    const { __scopeMenu, ...separatorProps } = props;\n    return (\n      <Primitive.div\n        role=\"separator\"\n        aria-orientation=\"horizontal\"\n        {...separatorProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nMenuSeparator.displayName = SEPARATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'MenuArrow';\n\ntype MenuArrowElement = React.ElementRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface MenuArrowProps extends PopperArrowProps {}\n\nconst MenuArrow = React.forwardRef<MenuArrowElement, MenuArrowProps>(\n  (props: ScopedProps<MenuArrowProps>, forwardedRef) => {\n    const { __scopeMenu, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />;\n  }\n);\n\nMenuArrow.displayName = ARROW_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSub\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_NAME = 'MenuSub';\n\ntype MenuSubContextValue = {\n  contentId: string;\n  triggerId: string;\n  trigger: MenuSubTriggerElement | null;\n  onTriggerChange(trigger: MenuSubTriggerElement | null): void;\n};\n\nconst [MenuSubProvider, useMenuSubContext] = createMenuContext<MenuSubContextValue>(SUB_NAME);\n\ninterface MenuSubProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n}\n\nconst MenuSub: React.FC<MenuSubProps> = (props: ScopedProps<MenuSubProps>) => {\n  const { __scopeMenu, children, open = false, onOpenChange } = props;\n  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);\n  const popperScope = usePopperScope(__scopeMenu);\n  const [trigger, setTrigger] = React.useState<MenuSubTriggerElement | null>(null);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n\n  // Prevent the parent menu from reopening with open submenus.\n  React.useEffect(() => {\n    if (parentMenuContext.open === false) handleOpenChange(false);\n    return () => handleOpenChange(false);\n  }, [parentMenuContext.open, handleOpenChange]);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n      >\n        <MenuSubProvider\n          scope={__scopeMenu}\n          contentId={useId()}\n          triggerId={useId()}\n          trigger={trigger}\n          onTriggerChange={setTrigger}\n        >\n          {children}\n        </MenuSubProvider>\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenuSub.displayName = SUB_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSubTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_TRIGGER_NAME = 'MenuSubTrigger';\n\ntype MenuSubTriggerElement = MenuItemImplElement;\ninterface MenuSubTriggerProps extends MenuItemImplProps {}\n\nconst MenuSubTrigger = React.forwardRef<MenuSubTriggerElement, MenuSubTriggerProps>(\n  (props: ScopedProps<MenuSubTriggerProps>, forwardedRef) => {\n    const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const openTimerRef = React.useRef<number | null>(null);\n    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;\n    const scope = { __scopeMenu: props.__scopeMenu };\n\n    const clearOpenTimer = React.useCallback(() => {\n      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);\n      openTimerRef.current = null;\n    }, []);\n\n    React.useEffect(() => clearOpenTimer, [clearOpenTimer]);\n\n    React.useEffect(() => {\n      const pointerGraceTimer = pointerGraceTimerRef.current;\n      return () => {\n        window.clearTimeout(pointerGraceTimer);\n        onPointerGraceIntentChange(null);\n      };\n    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);\n\n    return (\n      <MenuAnchor asChild {...scope}>\n        <MenuItemImpl\n          id={subContext.triggerId}\n          aria-haspopup=\"menu\"\n          aria-expanded={context.open}\n          aria-controls={subContext.contentId}\n          data-state={getOpenState(context.open)}\n          {...props}\n          ref={composeRefs(forwardedRef, subContext.onTriggerChange)}\n          // This is redundant for mouse users but we cannot determine pointer type from\n          // click event and we cannot use pointerup event (see git history for reasons why)\n          onClick={(event) => {\n            props.onClick?.(event);\n            if (props.disabled || event.defaultPrevented) return;\n            /**\n             * We manually focus because iOS Safari doesn't always focus on click (e.g. buttons)\n             * and we rely heavily on `onFocusOutside` for submenus to close when switching\n             * between separate submenus.\n             */\n            event.currentTarget.focus();\n            if (!context.open) context.onOpenChange(true);\n          }}\n          onPointerMove={composeEventHandlers(\n            props.onPointerMove,\n            whenMouse((event) => {\n              contentContext.onItemEnter(event);\n              if (event.defaultPrevented) return;\n              if (!props.disabled && !context.open && !openTimerRef.current) {\n                contentContext.onPointerGraceIntentChange(null);\n                openTimerRef.current = window.setTimeout(() => {\n                  context.onOpenChange(true);\n                  clearOpenTimer();\n                }, 100);\n              }\n            })\n          )}\n          onPointerLeave={composeEventHandlers(\n            props.onPointerLeave,\n            whenMouse((event) => {\n              clearOpenTimer();\n\n              const contentRect = context.content?.getBoundingClientRect();\n              if (contentRect) {\n                // TODO: make sure to update this when we change positioning logic\n                const side = context.content?.dataset.side as Side;\n                const rightSide = side === 'right';\n                const bleed = rightSide ? -5 : +5;\n                const contentNearEdge = contentRect[rightSide ? 'left' : 'right'];\n                const contentFarEdge = contentRect[rightSide ? 'right' : 'left'];\n\n                contentContext.onPointerGraceIntentChange({\n                  area: [\n                    // Apply a bleed on clientX to ensure that our exit point is\n                    // consistently within polygon bounds\n                    { x: event.clientX + bleed, y: event.clientY },\n                    { x: contentNearEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.bottom },\n                    { x: contentNearEdge, y: contentRect.bottom },\n                  ],\n                  side,\n                });\n\n                window.clearTimeout(pointerGraceTimerRef.current);\n                pointerGraceTimerRef.current = window.setTimeout(\n                  () => contentContext.onPointerGraceIntentChange(null),\n                  300\n                );\n              } else {\n                contentContext.onTriggerLeave(event);\n                if (event.defaultPrevented) return;\n\n                // There's 100ms where the user may leave an item before the submenu was opened.\n                contentContext.onPointerGraceIntentChange(null);\n              }\n            })\n          )}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            const isTypingAhead = contentContext.searchRef.current !== '';\n            if (props.disabled || (isTypingAhead && event.key === ' ')) return;\n            if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {\n              context.onOpenChange(true);\n              // The trigger may hold focus if opened via pointer interaction\n              // so we ensure content is given focus again when switching to keyboard.\n              context.content?.focus();\n              // prevent window from scrolling\n              event.preventDefault();\n            }\n          })}\n        />\n      </MenuAnchor>\n    );\n  }\n);\n\nMenuSubTrigger.displayName = SUB_TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSubContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_CONTENT_NAME = 'MenuSubContent';\n\ntype MenuSubContentElement = MenuContentImplElement;\ninterface MenuSubContentProps\n  extends Omit<\n    MenuContentImplProps,\n    keyof MenuContentImplPrivateProps | 'onCloseAutoFocus' | 'onEntryFocus' | 'side' | 'align'\n  > {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuSubContent = React.forwardRef<MenuSubContentElement, MenuSubContentProps>(\n  (props: ScopedProps<MenuSubContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n    const { forceMount = portalContext.forceMount, ...subContentProps } = props;\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n    const subContext = useMenuSubContext(SUB_CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuSubContentElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    return (\n      <Collection.Provider scope={props.__scopeMenu}>\n        <Presence present={forceMount || context.open}>\n          <Collection.Slot scope={props.__scopeMenu}>\n            <MenuContentImpl\n              id={subContext.contentId}\n              aria-labelledby={subContext.triggerId}\n              {...subContentProps}\n              ref={composedRefs}\n              align=\"start\"\n              side={rootContext.dir === 'rtl' ? 'left' : 'right'}\n              disableOutsidePointerEvents={false}\n              disableOutsideScroll={false}\n              trapFocus={false}\n              onOpenAutoFocus={(event) => {\n                // when opening a submenu, focus content for keyboard users only\n                if (rootContext.isUsingKeyboardRef.current) ref.current?.focus();\n                event.preventDefault();\n              }}\n              // The menu might close because of focusing another menu item in the parent menu. We\n              // don't want it to refocus the trigger in that case so we handle trigger focus ourselves.\n              onCloseAutoFocus={(event) => event.preventDefault()}\n              onFocusOutside={composeEventHandlers(props.onFocusOutside, (event) => {\n                // We prevent closing when the trigger is focused to avoid triggering a re-open animation\n                // on pointer interaction.\n                if (event.target !== subContext.trigger) context.onOpenChange(false);\n              })}\n              onEscapeKeyDown={composeEventHandlers(props.onEscapeKeyDown, (event) => {\n                rootContext.onClose();\n                // ensure pressing escape in submenu doesn't escape full screen mode\n                event.preventDefault();\n              })}\n              onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                // Submenu key events bubble through portals. We only care about keys in this menu.\n                const isKeyDownInside = event.currentTarget.contains(event.target as HTMLElement);\n                const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);\n                if (isKeyDownInside && isCloseKey) {\n                  context.onOpenChange(false);\n                  // We focus manually because we prevented it in `onCloseAutoFocus`\n                  subContext.trigger?.focus();\n                  // prevent window from scrolling\n                  event.preventDefault();\n                }\n              })}\n            />\n          </Collection.Slot>\n        </Presence>\n      </Collection.Provider>\n    );\n  }\n);\n\nMenuSubContent.displayName = SUB_CONTENT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getOpenState(open: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nfunction isIndeterminate(checked?: CheckedState): checked is 'indeterminate' {\n  return checked === 'indeterminate';\n}\n\nfunction getCheckedState(checked: CheckedState) {\n  return isIndeterminate(checked) ? 'indeterminate' : checked ? 'checked' : 'unchecked';\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\n/**\n * This is the \"meat\" of the typeahead matching logic. It takes in all the values,\n * the search and the current match, and returns the next match (or `undefined`).\n *\n * We normalize the search because if a user has repeatedly pressed a character,\n * we want the exact same behavior as if we only had that one character\n * (ie. cycle through options starting with that character)\n *\n * We also reorder the values by wrapping the array around the current match.\n * This is so we always look forward from the current match, and picking the first\n * match will always be the correct one.\n *\n * Finally, if the normalized search is exactly one character, we exclude the\n * current match from the values because otherwise it would be the first to match always\n * and focus would never move. This is as opposed to the regular case, where we\n * don't want focus to move if the current match still matches.\n */\nfunction getNextMatch(values: string[], search: string, currentMatch?: string) {\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0] : search;\n  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;\n  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));\n  const excludeCurrentMatch = normalizedSearch.length === 1;\n  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);\n  const nextMatch = wrappedValues.find((value) =>\n    value.toLowerCase().startsWith(normalizedSearch.toLowerCase())\n  );\n  return nextMatch !== currentMatch ? nextMatch : undefined;\n}\n\ntype Point = { x: number; y: number };\ntype Polygon = Point[];\ntype Side = 'left' | 'right';\ntype GraceIntent = { area: Polygon; side: Side };\n\n// Determine if a point is inside of a polygon.\n// Based on https://github.com/substack/point-in-polygon\nfunction isPointInPolygon(point: Point, polygon: Polygon) {\n  const { x, y } = point;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n\n    // prettier-ignore\n    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n    if (intersect) inside = !inside;\n  }\n\n  return inside;\n}\n\nfunction isPointerInGraceArea(event: React.PointerEvent, area?: Polygon) {\n  if (!area) return false;\n  const cursorPos = { x: event.clientX, y: event.clientY };\n  return isPointInPolygon(cursorPos, area);\n}\n\nfunction whenMouse<E>(handler: React.PointerEventHandler<E>): React.PointerEventHandler<E> {\n  return (event) => (event.pointerType === 'mouse' ? handler(event) : undefined);\n}\n\nconst Root = Menu;\nconst Anchor = MenuAnchor;\nconst Portal = MenuPortal;\nconst Content = MenuContent;\nconst Group = MenuGroup;\nconst Label = MenuLabel;\nconst Item = MenuItem;\nconst CheckboxItem = MenuCheckboxItem;\nconst RadioGroup = MenuRadioGroup;\nconst RadioItem = MenuRadioItem;\nconst ItemIndicator = MenuItemIndicator;\nconst Separator = MenuSeparator;\nconst Arrow = MenuArrow;\nconst Sub = MenuSub;\nconst SubTrigger = MenuSubTrigger;\nconst SubContent = MenuSubContent;\n\nexport {\n  createMenuScope,\n  //\n  Menu,\n  MenuAnchor,\n  MenuPortal,\n  MenuContent,\n  MenuGroup,\n  MenuLabel,\n  MenuItem,\n  MenuCheckboxItem,\n  MenuRadioGroup,\n  MenuRadioItem,\n  MenuItemIndicator,\n  MenuSeparator,\n  MenuArrow,\n  MenuSub,\n  MenuSubTrigger,\n  MenuSubContent,\n  //\n  Root,\n  Anchor,\n  Portal,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n  Sub,\n  SubTrigger,\n  SubContent,\n};\nexport type {\n  MenuProps,\n  MenuAnchorProps,\n  MenuPortalProps,\n  MenuContentProps,\n  MenuGroupProps,\n  MenuLabelProps,\n  MenuItemProps,\n  MenuCheckboxItemProps,\n  MenuRadioGroupProps,\n  MenuRadioItemProps,\n  MenuItemIndicatorProps,\n  MenuSeparatorProps,\n  MenuArrowProps,\n  MenuSubProps,\n  MenuSubTriggerProps,\n  MenuSubContentProps,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}