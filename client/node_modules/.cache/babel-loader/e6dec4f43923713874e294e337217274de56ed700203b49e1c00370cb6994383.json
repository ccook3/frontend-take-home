{"ast":null,"code":"\"use strict\";\n\"use client\";\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n// If the importer is in node compatibility mode or this is not an ESM\n// file that has been converted to a CommonJS file using a Babel-\n// compatible transform (i.e. \"__esModule\" has not been set), then set\n// \"default\" to the CommonJS \"module.exports\" for node compatibility.\nisNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// packages/react/presence/src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  Presence: () => Presence\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// packages/react/presence/src/Presence.tsx\nvar React2 = __toESM(require(\"react\"));\nvar import_react_compose_refs = require(\"@radix-ui/react-compose-refs\");\nvar import_react_use_layout_effect = require(\"@radix-ui/react-use-layout-effect\");\n\n// packages/react/presence/src/useStateMachine.tsx\nvar React = __toESM(require(\"react\"));\nfunction useStateMachine(initialState, machine) {\n  return React.useReducer((state, event) => {\n    const nextState = machine[state][event];\n    return nextState ?? state;\n  }, initialState);\n}\n\n// packages/react/presence/src/Presence.tsx\nvar Presence = props => {\n  const {\n    present,\n    children\n  } = props;\n  const presence = usePresence(present);\n  const child = typeof children === \"function\" ? children({\n    present: presence.isPresent\n  }) : React2.Children.only(children);\n  const ref = (0, import_react_compose_refs.useComposedRefs)(presence.ref, getElementRef(child));\n  const forceMount = typeof children === \"function\";\n  return forceMount || presence.isPresent ? React2.cloneElement(child, {\n    ref\n  }) : null;\n};\nPresence.displayName = \"Presence\";\nfunction usePresence(present) {\n  const [node, setNode] = React2.useState();\n  const stylesRef = React2.useRef({});\n  const prevPresentRef = React2.useRef(present);\n  const prevAnimationNameRef = React2.useRef(\"none\");\n  const initialState = present ? \"mounted\" : \"unmounted\";\n  const [state, send] = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: \"unmounted\",\n      ANIMATION_OUT: \"unmountSuspended\"\n    },\n    unmountSuspended: {\n      MOUNT: \"mounted\",\n      ANIMATION_END: \"unmounted\"\n    },\n    unmounted: {\n      MOUNT: \"mounted\"\n    }\n  });\n  React2.useEffect(() => {\n    const currentAnimationName = getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === \"mounted\" ? currentAnimationName : \"none\";\n  }, [state]);\n  (0, import_react_use_layout_effect.useLayoutEffect)(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n      if (present) {\n        send(\"MOUNT\");\n      } else if (currentAnimationName === \"none\" || styles?.display === \"none\") {\n        send(\"UNMOUNT\");\n      } else {\n        const isAnimating = prevAnimationName !== currentAnimationName;\n        if (wasPresent && isAnimating) {\n          send(\"ANIMATION_OUT\");\n        } else {\n          send(\"UNMOUNT\");\n        }\n      }\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n  (0, import_react_use_layout_effect.useLayoutEffect)(() => {\n    if (node) {\n      let timeoutId;\n      const ownerWindow = node.ownerDocument.defaultView ?? window;\n      const handleAnimationEnd = event => {\n        const currentAnimationName = getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n        if (event.target === node && isCurrentAnimation) {\n          send(\"ANIMATION_END\");\n          if (!prevPresentRef.current) {\n            const currentFillMode = node.style.animationFillMode;\n            node.style.animationFillMode = \"forwards\";\n            timeoutId = ownerWindow.setTimeout(() => {\n              if (node.style.animationFillMode === \"forwards\") {\n                node.style.animationFillMode = currentFillMode;\n              }\n            });\n          }\n        }\n      };\n      const handleAnimationStart = event => {\n        if (event.target === node) {\n          prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n        }\n      };\n      node.addEventListener(\"animationstart\", handleAnimationStart);\n      node.addEventListener(\"animationcancel\", handleAnimationEnd);\n      node.addEventListener(\"animationend\", handleAnimationEnd);\n      return () => {\n        ownerWindow.clearTimeout(timeoutId);\n        node.removeEventListener(\"animationstart\", handleAnimationStart);\n        node.removeEventListener(\"animationcancel\", handleAnimationEnd);\n        node.removeEventListener(\"animationend\", handleAnimationEnd);\n      };\n    } else {\n      send(\"ANIMATION_END\");\n    }\n  }, [node, send]);\n  return {\n    isPresent: [\"mounted\", \"unmountSuspended\"].includes(state),\n    ref: React2.useCallback(node2 => {\n      if (node2) stylesRef.current = getComputedStyle(node2);\n      setNode(node2);\n    }, [])\n  };\n}\nfunction getAnimationName(styles) {\n  return styles?.animationName || \"none\";\n}\nfunction getElementRef(element) {\n  let getter = Object.getOwnPropertyDescriptor(element.props, \"ref\")?.get;\n  let mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.ref;\n  }\n  getter = Object.getOwnPropertyDescriptor(element, \"ref\")?.get;\n  mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.props.ref;\n  }\n  return element.props.ref || element.ref;\n}","map":{"version":3,"names":["src_exports","__export","Presence","module","exports","__toCommonJS","React2","__toESM","require","import_react_compose_refs","import_react_use_layout_effect","React","useStateMachine","initialState","machine","useReducer","state","event","nextState","props","present","children","presence","usePresence","child","isPresent","Children","only","ref","useComposedRefs","getElementRef","forceMount","cloneElement","displayName","node","setNode","useState","stylesRef","useRef","prevPresentRef","prevAnimationNameRef","send","mounted","UNMOUNT","ANIMATION_OUT","unmountSuspended","MOUNT","ANIMATION_END","unmounted","useEffect","currentAnimationName","getAnimationName","current","useLayoutEffect","styles","wasPresent","hasPresentChanged","prevAnimationName","display","isAnimating","timeoutId","ownerWindow","ownerDocument","defaultView","window","handleAnimationEnd","isCurrentAnimation","includes","animationName","target","currentFillMode","style","animationFillMode","setTimeout","handleAnimationStart","addEventListener","clearTimeout","removeEventListener","useCallback","node2","getComputedStyle","element","getter","Object","getOwnPropertyDescriptor","get","mayWarn","isReactWarning"],"sources":["/Users/catiecook/Documents/workos/frontend-take-home/client/node_modules/@radix-ui/react-presence/src/index.ts","/Users/catiecook/Documents/workos/frontend-take-home/client/node_modules/@radix-ui/react-presence/src/Presence.tsx","/Users/catiecook/Documents/workos/frontend-take-home/client/node_modules/@radix-ui/react-presence/src/useStateMachine.tsx"],"sourcesContent":["'use client';\nexport { Presence } from './Presence';\nexport type { PresenceProps } from './Presence';\n","import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useStateMachine } from './useStateMachine';\n\ninterface PresenceProps {\n  children: React.ReactElement | ((props: { present: boolean }) => React.ReactElement);\n  present: boolean;\n}\n\nconst Presence: React.FC<PresenceProps> = (props) => {\n  const { present, children } = props;\n  const presence = usePresence(present);\n\n  const child = (\n    typeof children === 'function'\n      ? children({ present: presence.isPresent })\n      : React.Children.only(children)\n  ) as React.ReactElement<{ ref?: React.Ref<HTMLElement> }>;\n\n  const ref = useComposedRefs(presence.ref, getElementRef(child));\n  const forceMount = typeof children === 'function';\n  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;\n};\n\nPresence.displayName = 'Presence';\n\n/* -------------------------------------------------------------------------------------------------\n * usePresence\n * -----------------------------------------------------------------------------------------------*/\n\nfunction usePresence(present: boolean) {\n  const [node, setNode] = React.useState<HTMLElement>();\n  const stylesRef = React.useRef<CSSStyleDeclaration>({} as any);\n  const prevPresentRef = React.useRef(present);\n  const prevAnimationNameRef = React.useRef<string>('none');\n  const initialState = present ? 'mounted' : 'unmounted';\n  const [state, send] = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: 'unmounted',\n      ANIMATION_OUT: 'unmountSuspended',\n    },\n    unmountSuspended: {\n      MOUNT: 'mounted',\n      ANIMATION_END: 'unmounted',\n    },\n    unmounted: {\n      MOUNT: 'mounted',\n    },\n  });\n\n  React.useEffect(() => {\n    const currentAnimationName = getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === 'mounted' ? currentAnimationName : 'none';\n  }, [state]);\n\n  useLayoutEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n\n      if (present) {\n        send('MOUNT');\n      } else if (currentAnimationName === 'none' || styles?.display === 'none') {\n        // If there is no exit animation or the element is hidden, animations won't run\n        // so we unmount instantly\n        send('UNMOUNT');\n      } else {\n        /**\n         * When `present` changes to `false`, we check changes to animation-name to\n         * determine whether an animation has started. We chose this approach (reading\n         * computed styles) because there is no `animationrun` event and `animationstart`\n         * fires after `animation-delay` has expired which would be too late.\n         */\n        const isAnimating = prevAnimationName !== currentAnimationName;\n\n        if (wasPresent && isAnimating) {\n          send('ANIMATION_OUT');\n        } else {\n          send('UNMOUNT');\n        }\n      }\n\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n\n  useLayoutEffect(() => {\n    if (node) {\n      let timeoutId: number;\n      const ownerWindow = node.ownerDocument.defaultView ?? window;\n      /**\n       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n       * make sure we only trigger ANIMATION_END for the currently active animation.\n       */\n      const handleAnimationEnd = (event: AnimationEvent) => {\n        const currentAnimationName = getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n        if (event.target === node && isCurrentAnimation) {\n          // With React 18 concurrency this update is applied a frame after the\n          // animation ends, creating a flash of visible content. By setting the\n          // animation fill mode to \"forwards\", we force the node to keep the\n          // styles of the last keyframe, removing the flash.\n          //\n          // Previously we flushed the update via ReactDom.flushSync, but with\n          // exit animations this resulted in the node being removed from the\n          // DOM before the synthetic animationEnd event was dispatched, meaning\n          // user-provided event handlers would not be called.\n          // https://github.com/radix-ui/primitives/pull/1849\n          send('ANIMATION_END');\n          if (!prevPresentRef.current) {\n            const currentFillMode = node.style.animationFillMode;\n            node.style.animationFillMode = 'forwards';\n            // Reset the style after the node had time to unmount (for cases\n            // where the component chooses not to unmount). Doing this any\n            // sooner than `setTimeout` (e.g. with `requestAnimationFrame`)\n            // still causes a flash.\n            timeoutId = ownerWindow.setTimeout(() => {\n              if (node.style.animationFillMode === 'forwards') {\n                node.style.animationFillMode = currentFillMode;\n              }\n            });\n          }\n        }\n      };\n      const handleAnimationStart = (event: AnimationEvent) => {\n        if (event.target === node) {\n          // if animation occurred, store its name as the previous animation.\n          prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n        }\n      };\n      node.addEventListener('animationstart', handleAnimationStart);\n      node.addEventListener('animationcancel', handleAnimationEnd);\n      node.addEventListener('animationend', handleAnimationEnd);\n      return () => {\n        ownerWindow.clearTimeout(timeoutId);\n        node.removeEventListener('animationstart', handleAnimationStart);\n        node.removeEventListener('animationcancel', handleAnimationEnd);\n        node.removeEventListener('animationend', handleAnimationEnd);\n      };\n    } else {\n      // Transition to the unmounted state if the node is removed prematurely.\n      // We avoid doing so during cleanup as the node may change but still exist.\n      send('ANIMATION_END');\n    }\n  }, [node, send]);\n\n  return {\n    isPresent: ['mounted', 'unmountSuspended'].includes(state),\n    ref: React.useCallback((node: HTMLElement) => {\n      if (node) stylesRef.current = getComputedStyle(node);\n      setNode(node);\n    }, []),\n  };\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getAnimationName(styles?: CSSStyleDeclaration) {\n  return styles?.animationName || 'none';\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement<{ ref?: React.Ref<unknown> }>) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.props.ref;\n  }\n\n  // Not DEV\n  return element.props.ref || (element as any).ref;\n}\n\nexport { Presence };\nexport type { PresenceProps };\n","import * as React from 'react';\n\ntype Machine<S> = { [k: string]: { [k: string]: S } };\ntype MachineState<T> = keyof T;\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>;\n\n// 🤯 https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any\n  ? R\n  : never;\n\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>\n) {\n  return React.useReducer((state: MachineState<M>, event: MachineEvent<M>): MachineState<M> => {\n    const nextState = (machine[state] as any)[event];\n    return nextState ?? state;\n  }, initialState);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAAA,WAAA;AAAAC,QAAA,CAAAD,WAAA;EAAAE,QAAA,EAAAA,CAAA,KAAAA;AAAA;AAAAC,MAAA,CAAAC,OAAA,GAAAC,YAAA,CAAAL,WAAA;;;ACAA,IAAAM,MAAA,GAAuBC,OAAA,CAAAC,OAAA;AACvB,IAAAC,yBAAA,GAAgCD,OAAA;AAChC,IAAAE,8BAAA,GAAgCF,OAAA;;;ACFhC,IAAAG,KAAA,GAAuBJ,OAAA,CAAAC,OAAA;AAWhB,SAASI,gBACdC,YAAA,EACAC,OAAA,EACA;EACA,OAAaH,KAAA,CAAAI,UAAA,CAAW,CAACC,KAAA,EAAwBC,KAAA,KAA4C;IAC3F,MAAMC,SAAA,GAAaJ,OAAA,CAAQE,KAAK,EAAUC,KAAK;IAC/C,OAAOC,SAAA,IAAaF,KAAA;EACtB,GAAGH,YAAY;AACjB;;;ADTA,IAAMX,QAAA,GAAqCiB,KAAA,IAAU;EACnD,MAAM;IAAEC,OAAA;IAASC;EAAS,IAAIF,KAAA;EAC9B,MAAMG,QAAA,GAAWC,WAAA,CAAYH,OAAO;EAEpC,MAAMI,KAAA,GACJ,OAAOH,QAAA,KAAa,aAChBA,QAAA,CAAS;IAAED,OAAA,EAASE,QAAA,CAASG;EAAU,CAAC,IAClCnB,MAAA,CAAAoB,QAAA,CAASC,IAAA,CAAKN,QAAQ;EAGlC,MAAMO,GAAA,OAAMnB,yBAAA,CAAAoB,eAAA,EAAgBP,QAAA,CAASM,GAAA,EAAKE,aAAA,CAAcN,KAAK,CAAC;EAC9D,MAAMO,UAAA,GAAa,OAAOV,QAAA,KAAa;EACvC,OAAOU,UAAA,IAAcT,QAAA,CAASG,SAAA,GAAkBnB,MAAA,CAAA0B,YAAA,CAAaR,KAAA,EAAO;IAAEI;EAAI,CAAC,IAAI;AACjF;AAEA1B,QAAA,CAAS+B,WAAA,GAAc;AAMvB,SAASV,YAAYH,OAAA,EAAkB;EACrC,MAAM,CAACc,IAAA,EAAMC,OAAO,IAAU7B,MAAA,CAAA8B,QAAA,CAAsB;EACpD,MAAMC,SAAA,GAAkB/B,MAAA,CAAAgC,MAAA,CAA4B,CAAC,CAAQ;EAC7D,MAAMC,cAAA,GAAuBjC,MAAA,CAAAgC,MAAA,CAAOlB,OAAO;EAC3C,MAAMoB,oBAAA,GAA6BlC,MAAA,CAAAgC,MAAA,CAAe,MAAM;EACxD,MAAMzB,YAAA,GAAeO,OAAA,GAAU,YAAY;EAC3C,MAAM,CAACJ,KAAA,EAAOyB,IAAI,IAAI7B,eAAA,CAAgBC,YAAA,EAAc;IAClD6B,OAAA,EAAS;MACPC,OAAA,EAAS;MACTC,aAAA,EAAe;IACjB;IACAC,gBAAA,EAAkB;MAChBC,KAAA,EAAO;MACPC,aAAA,EAAe;IACjB;IACAC,SAAA,EAAW;MACTF,KAAA,EAAO;IACT;EACF,CAAC;EAEKxC,MAAA,CAAA2C,SAAA,CAAU,MAAM;IACpB,MAAMC,oBAAA,GAAuBC,gBAAA,CAAiBd,SAAA,CAAUe,OAAO;IAC/DZ,oBAAA,CAAqBY,OAAA,GAAUpC,KAAA,KAAU,YAAYkC,oBAAA,GAAuB;EAC9E,GAAG,CAAClC,KAAK,CAAC;EAEV,IAAAN,8BAAA,CAAA2C,eAAA,EAAgB,MAAM;IACpB,MAAMC,MAAA,GAASjB,SAAA,CAAUe,OAAA;IACzB,MAAMG,UAAA,GAAahB,cAAA,CAAea,OAAA;IAClC,MAAMI,iBAAA,GAAoBD,UAAA,KAAenC,OAAA;IAEzC,IAAIoC,iBAAA,EAAmB;MACrB,MAAMC,iBAAA,GAAoBjB,oBAAA,CAAqBY,OAAA;MAC/C,MAAMF,oBAAA,GAAuBC,gBAAA,CAAiBG,MAAM;MAEpD,IAAIlC,OAAA,EAAS;QACXqB,IAAA,CAAK,OAAO;MACd,WAAWS,oBAAA,KAAyB,UAAUI,MAAA,EAAQI,OAAA,KAAY,QAAQ;QAGxEjB,IAAA,CAAK,SAAS;MAChB,OAAO;QAOL,MAAMkB,WAAA,GAAcF,iBAAA,KAAsBP,oBAAA;QAE1C,IAAIK,UAAA,IAAcI,WAAA,EAAa;UAC7BlB,IAAA,CAAK,eAAe;QACtB,OAAO;UACLA,IAAA,CAAK,SAAS;QAChB;MACF;MAEAF,cAAA,CAAea,OAAA,GAAUhC,OAAA;IAC3B;EACF,GAAG,CAACA,OAAA,EAASqB,IAAI,CAAC;EAElB,IAAA/B,8BAAA,CAAA2C,eAAA,EAAgB,MAAM;IACpB,IAAInB,IAAA,EAAM;MACR,IAAI0B,SAAA;MACJ,MAAMC,WAAA,GAAc3B,IAAA,CAAK4B,aAAA,CAAcC,WAAA,IAAeC,MAAA;MAMtD,MAAMC,kBAAA,GAAsBhD,KAAA,IAA0B;QACpD,MAAMiC,oBAAA,GAAuBC,gBAAA,CAAiBd,SAAA,CAAUe,OAAO;QAC/D,MAAMc,kBAAA,GAAqBhB,oBAAA,CAAqBiB,QAAA,CAASlD,KAAA,CAAMmD,aAAa;QAC5E,IAAInD,KAAA,CAAMoD,MAAA,KAAWnC,IAAA,IAAQgC,kBAAA,EAAoB;UAW/CzB,IAAA,CAAK,eAAe;UACpB,IAAI,CAACF,cAAA,CAAea,OAAA,EAAS;YAC3B,MAAMkB,eAAA,GAAkBpC,IAAA,CAAKqC,KAAA,CAAMC,iBAAA;YACnCtC,IAAA,CAAKqC,KAAA,CAAMC,iBAAA,GAAoB;YAK/BZ,SAAA,GAAYC,WAAA,CAAYY,UAAA,CAAW,MAAM;cACvC,IAAIvC,IAAA,CAAKqC,KAAA,CAAMC,iBAAA,KAAsB,YAAY;gBAC/CtC,IAAA,CAAKqC,KAAA,CAAMC,iBAAA,GAAoBF,eAAA;cACjC;YACF,CAAC;UACH;QACF;MACF;MACA,MAAMI,oBAAA,GAAwBzD,KAAA,IAA0B;QACtD,IAAIA,KAAA,CAAMoD,MAAA,KAAWnC,IAAA,EAAM;UAEzBM,oBAAA,CAAqBY,OAAA,GAAUD,gBAAA,CAAiBd,SAAA,CAAUe,OAAO;QACnE;MACF;MACAlB,IAAA,CAAKyC,gBAAA,CAAiB,kBAAkBD,oBAAoB;MAC5DxC,IAAA,CAAKyC,gBAAA,CAAiB,mBAAmBV,kBAAkB;MAC3D/B,IAAA,CAAKyC,gBAAA,CAAiB,gBAAgBV,kBAAkB;MACxD,OAAO,MAAM;QACXJ,WAAA,CAAYe,YAAA,CAAahB,SAAS;QAClC1B,IAAA,CAAK2C,mBAAA,CAAoB,kBAAkBH,oBAAoB;QAC/DxC,IAAA,CAAK2C,mBAAA,CAAoB,mBAAmBZ,kBAAkB;QAC9D/B,IAAA,CAAK2C,mBAAA,CAAoB,gBAAgBZ,kBAAkB;MAC7D;IACF,OAAO;MAGLxB,IAAA,CAAK,eAAe;IACtB;EACF,GAAG,CAACP,IAAA,EAAMO,IAAI,CAAC;EAEf,OAAO;IACLhB,SAAA,EAAW,CAAC,WAAW,kBAAkB,EAAE0C,QAAA,CAASnD,KAAK;IACzDY,GAAA,EAAWtB,MAAA,CAAAwE,WAAA,CAAaC,KAAA,IAAsB;MAC5C,IAAIA,KAAA,EAAM1C,SAAA,CAAUe,OAAA,GAAU4B,gBAAA,CAAiBD,KAAI;MACnD5C,OAAA,CAAQ4C,KAAI;IACd,GAAG,EAAE;EACP;AACF;AAIA,SAAS5B,iBAAiBG,MAAA,EAA8B;EACtD,OAAOA,MAAA,EAAQc,aAAA,IAAiB;AAClC;AAOA,SAAStC,cAAcmD,OAAA,EAA2D;EAEhF,IAAIC,MAAA,GAASC,MAAA,CAAOC,wBAAA,CAAyBH,OAAA,CAAQ9D,KAAA,EAAO,KAAK,GAAGkE,GAAA;EACpE,IAAIC,OAAA,GAAUJ,MAAA,IAAU,oBAAoBA,MAAA,IAAUA,MAAA,CAAOK,cAAA;EAC7D,IAAID,OAAA,EAAS;IACX,OAAQL,OAAA,CAAgBrD,GAAA;EAC1B;EAGAsD,MAAA,GAASC,MAAA,CAAOC,wBAAA,CAAyBH,OAAA,EAAS,KAAK,GAAGI,GAAA;EAC1DC,OAAA,GAAUJ,MAAA,IAAU,oBAAoBA,MAAA,IAAUA,MAAA,CAAOK,cAAA;EACzD,IAAID,OAAA,EAAS;IACX,OAAOL,OAAA,CAAQ9D,KAAA,CAAMS,GAAA;EACvB;EAGA,OAAOqD,OAAA,CAAQ9D,KAAA,CAAMS,GAAA,IAAQqD,OAAA,CAAgBrD,GAAA;AAC/C","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}