{"ast":null,"code":"\"use strict\";\n\"use client\";\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n// If the importer is in node compatibility mode or this is not an ESM\n// file that has been converted to a CommonJS file using a Babel-\n// compatible transform (i.e. \"__esModule\" has not been set), then set\n// \"default\" to the CommonJS \"module.exports\" for node compatibility.\nisNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// packages/react/toast/src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  Action: () => Action,\n  Close: () => Close,\n  Description: () => Description,\n  Provider: () => Provider,\n  Root: () => Root2,\n  Title: () => Title,\n  Toast: () => Toast,\n  ToastAction: () => ToastAction,\n  ToastClose: () => ToastClose,\n  ToastDescription: () => ToastDescription,\n  ToastProvider: () => ToastProvider,\n  ToastTitle: () => ToastTitle,\n  ToastViewport: () => ToastViewport,\n  Viewport: () => Viewport,\n  createToastScope: () => createToastScope\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// packages/react/toast/src/toast.tsx\nvar React = __toESM(require(\"react\"));\nvar ReactDOM = __toESM(require(\"react-dom\"));\nvar import_primitive = require(\"@radix-ui/primitive\");\nvar import_react_compose_refs = require(\"@radix-ui/react-compose-refs\");\nvar import_react_collection = require(\"@radix-ui/react-collection\");\nvar import_react_context = require(\"@radix-ui/react-context\");\nvar DismissableLayer = __toESM(require(\"@radix-ui/react-dismissable-layer\"));\nvar import_react_portal = require(\"@radix-ui/react-portal\");\nvar import_react_presence = require(\"@radix-ui/react-presence\");\nvar import_react_primitive = require(\"@radix-ui/react-primitive\");\nvar import_react_use_callback_ref = require(\"@radix-ui/react-use-callback-ref\");\nvar import_react_use_controllable_state = require(\"@radix-ui/react-use-controllable-state\");\nvar import_react_use_layout_effect = require(\"@radix-ui/react-use-layout-effect\");\nvar import_react_visually_hidden = require(\"@radix-ui/react-visually-hidden\");\nvar import_jsx_runtime = require(\"react/jsx-runtime\");\nvar PROVIDER_NAME = \"ToastProvider\";\nvar [Collection, useCollection, createCollectionScope] = (0, import_react_collection.createCollection)(\"Toast\");\nvar [createToastContext, createToastScope] = (0, import_react_context.createContextScope)(\"Toast\", [createCollectionScope]);\nvar [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME);\nvar ToastProvider = props => {\n  const {\n    __scopeToast,\n    label = \"Notification\",\n    duration = 5e3,\n    swipeDirection = \"right\",\n    swipeThreshold = 50,\n    children\n  } = props;\n  const [viewport, setViewport] = React.useState(null);\n  const [toastCount, setToastCount] = React.useState(0);\n  const isFocusedToastEscapeKeyDownRef = React.useRef(false);\n  const isClosePausedRef = React.useRef(false);\n  if (!label.trim()) {\n    console.error(`Invalid prop \\`label\\` supplied to \\`${PROVIDER_NAME}\\`. Expected non-empty \\`string\\`.`);\n  }\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(Collection.Provider, {\n    scope: __scopeToast,\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(ToastProviderProvider, {\n      scope: __scopeToast,\n      label,\n      duration,\n      swipeDirection,\n      swipeThreshold,\n      toastCount,\n      viewport,\n      onViewportChange: setViewport,\n      onToastAdd: React.useCallback(() => setToastCount(prevCount => prevCount + 1), []),\n      onToastRemove: React.useCallback(() => setToastCount(prevCount => prevCount - 1), []),\n      isFocusedToastEscapeKeyDownRef,\n      isClosePausedRef,\n      children\n    })\n  });\n};\nToastProvider.displayName = PROVIDER_NAME;\nvar VIEWPORT_NAME = \"ToastViewport\";\nvar VIEWPORT_DEFAULT_HOTKEY = [\"F8\"];\nvar VIEWPORT_PAUSE = \"toast.viewportPause\";\nvar VIEWPORT_RESUME = \"toast.viewportResume\";\nvar ToastViewport = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    hotkey = VIEWPORT_DEFAULT_HOTKEY,\n    label = \"Notifications ({hotkey})\",\n    ...viewportProps\n  } = props;\n  const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);\n  const getItems = useCollection(__scopeToast);\n  const wrapperRef = React.useRef(null);\n  const headFocusProxyRef = React.useRef(null);\n  const tailFocusProxyRef = React.useRef(null);\n  const ref = React.useRef(null);\n  const composedRefs = (0, import_react_compose_refs.useComposedRefs)(forwardedRef, ref, context.onViewportChange);\n  const hotkeyLabel = hotkey.join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\");\n  const hasToasts = context.toastCount > 0;\n  React.useEffect(() => {\n    const handleKeyDown = event => {\n      const isHotkeyPressed = hotkey.length !== 0 && hotkey.every(key => event[key] || event.code === key);\n      if (isHotkeyPressed) ref.current?.focus();\n    };\n    document.addEventListener(\"keydown\", handleKeyDown);\n    return () => document.removeEventListener(\"keydown\", handleKeyDown);\n  }, [hotkey]);\n  React.useEffect(() => {\n    const wrapper = wrapperRef.current;\n    const viewport = ref.current;\n    if (hasToasts && wrapper && viewport) {\n      const handlePause = () => {\n        if (!context.isClosePausedRef.current) {\n          const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);\n          viewport.dispatchEvent(pauseEvent);\n          context.isClosePausedRef.current = true;\n        }\n      };\n      const handleResume = () => {\n        if (context.isClosePausedRef.current) {\n          const resumeEvent = new CustomEvent(VIEWPORT_RESUME);\n          viewport.dispatchEvent(resumeEvent);\n          context.isClosePausedRef.current = false;\n        }\n      };\n      const handleFocusOutResume = event => {\n        const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);\n        if (isFocusMovingOutside) handleResume();\n      };\n      const handlePointerLeaveResume = () => {\n        const isFocusInside = wrapper.contains(document.activeElement);\n        if (!isFocusInside) handleResume();\n      };\n      wrapper.addEventListener(\"focusin\", handlePause);\n      wrapper.addEventListener(\"focusout\", handleFocusOutResume);\n      wrapper.addEventListener(\"pointermove\", handlePause);\n      wrapper.addEventListener(\"pointerleave\", handlePointerLeaveResume);\n      window.addEventListener(\"blur\", handlePause);\n      window.addEventListener(\"focus\", handleResume);\n      return () => {\n        wrapper.removeEventListener(\"focusin\", handlePause);\n        wrapper.removeEventListener(\"focusout\", handleFocusOutResume);\n        wrapper.removeEventListener(\"pointermove\", handlePause);\n        wrapper.removeEventListener(\"pointerleave\", handlePointerLeaveResume);\n        window.removeEventListener(\"blur\", handlePause);\n        window.removeEventListener(\"focus\", handleResume);\n      };\n    }\n  }, [hasToasts, context.isClosePausedRef]);\n  const getSortedTabbableCandidates = React.useCallback(({\n    tabbingDirection\n  }) => {\n    const toastItems = getItems();\n    const tabbableCandidates = toastItems.map(toastItem => {\n      const toastNode = toastItem.ref.current;\n      const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];\n      return tabbingDirection === \"forwards\" ? toastTabbableCandidates : toastTabbableCandidates.reverse();\n    });\n    return (tabbingDirection === \"forwards\" ? tabbableCandidates.reverse() : tabbableCandidates).flat();\n  }, [getItems]);\n  React.useEffect(() => {\n    const viewport = ref.current;\n    if (viewport) {\n      const handleKeyDown = event => {\n        const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n        const isTabKey = event.key === \"Tab\" && !isMetaKey;\n        if (isTabKey) {\n          const focusedElement = document.activeElement;\n          const isTabbingBackwards = event.shiftKey;\n          const targetIsViewport = event.target === viewport;\n          if (targetIsViewport && isTabbingBackwards) {\n            headFocusProxyRef.current?.focus();\n            return;\n          }\n          const tabbingDirection = isTabbingBackwards ? \"backwards\" : \"forwards\";\n          const sortedCandidates = getSortedTabbableCandidates({\n            tabbingDirection\n          });\n          const index = sortedCandidates.findIndex(candidate => candidate === focusedElement);\n          if (focusFirst(sortedCandidates.slice(index + 1))) {\n            event.preventDefault();\n          } else {\n            isTabbingBackwards ? headFocusProxyRef.current?.focus() : tailFocusProxyRef.current?.focus();\n          }\n        }\n      };\n      viewport.addEventListener(\"keydown\", handleKeyDown);\n      return () => viewport.removeEventListener(\"keydown\", handleKeyDown);\n    }\n  }, [getItems, getSortedTabbableCandidates]);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsxs)(DismissableLayer.Branch, {\n    ref: wrapperRef,\n    role: \"region\",\n    \"aria-label\": label.replace(\"{hotkey}\", hotkeyLabel),\n    tabIndex: -1,\n    style: {\n      pointerEvents: hasToasts ? void 0 : \"none\"\n    },\n    children: [hasToasts && /* @__PURE__ */(0, import_jsx_runtime.jsx)(FocusProxy, {\n      ref: headFocusProxyRef,\n      onFocusFromOutsideViewport: () => {\n        const tabbableCandidates = getSortedTabbableCandidates({\n          tabbingDirection: \"forwards\"\n        });\n        focusFirst(tabbableCandidates);\n      }\n    }), /* @__PURE__ */(0, import_jsx_runtime.jsx)(Collection.Slot, {\n      scope: __scopeToast,\n      children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_primitive.Primitive.ol, {\n        tabIndex: -1,\n        ...viewportProps,\n        ref: composedRefs\n      })\n    }), hasToasts && /* @__PURE__ */(0, import_jsx_runtime.jsx)(FocusProxy, {\n      ref: tailFocusProxyRef,\n      onFocusFromOutsideViewport: () => {\n        const tabbableCandidates = getSortedTabbableCandidates({\n          tabbingDirection: \"backwards\"\n        });\n        focusFirst(tabbableCandidates);\n      }\n    })]\n  });\n});\nToastViewport.displayName = VIEWPORT_NAME;\nvar FOCUS_PROXY_NAME = \"ToastFocusProxy\";\nvar FocusProxy = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    onFocusFromOutsideViewport,\n    ...proxyProps\n  } = props;\n  const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_visually_hidden.VisuallyHidden, {\n    \"aria-hidden\": true,\n    tabIndex: 0,\n    ...proxyProps,\n    ref: forwardedRef,\n    style: {\n      position: \"fixed\"\n    },\n    onFocus: event => {\n      const prevFocusedElement = event.relatedTarget;\n      const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);\n      if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();\n    }\n  });\n});\nFocusProxy.displayName = FOCUS_PROXY_NAME;\nvar TOAST_NAME = \"Toast\";\nvar TOAST_SWIPE_START = \"toast.swipeStart\";\nvar TOAST_SWIPE_MOVE = \"toast.swipeMove\";\nvar TOAST_SWIPE_CANCEL = \"toast.swipeCancel\";\nvar TOAST_SWIPE_END = \"toast.swipeEnd\";\nvar Toast = React.forwardRef((props, forwardedRef) => {\n  const {\n    forceMount,\n    open: openProp,\n    defaultOpen,\n    onOpenChange,\n    ...toastProps\n  } = props;\n  const [open = true, setOpen] = (0, import_react_use_controllable_state.useControllableState)({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange\n  });\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_presence.Presence, {\n    present: forceMount || open,\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(ToastImpl, {\n      open,\n      ...toastProps,\n      ref: forwardedRef,\n      onClose: () => setOpen(false),\n      onPause: (0, import_react_use_callback_ref.useCallbackRef)(props.onPause),\n      onResume: (0, import_react_use_callback_ref.useCallbackRef)(props.onResume),\n      onSwipeStart: (0, import_primitive.composeEventHandlers)(props.onSwipeStart, event => {\n        event.currentTarget.setAttribute(\"data-swipe\", \"start\");\n      }),\n      onSwipeMove: (0, import_primitive.composeEventHandlers)(props.onSwipeMove, event => {\n        const {\n          x,\n          y\n        } = event.detail.delta;\n        event.currentTarget.setAttribute(\"data-swipe\", \"move\");\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-move-x\", `${x}px`);\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-move-y\", `${y}px`);\n      }),\n      onSwipeCancel: (0, import_primitive.composeEventHandlers)(props.onSwipeCancel, event => {\n        event.currentTarget.setAttribute(\"data-swipe\", \"cancel\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-y\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-end-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-end-y\");\n      }),\n      onSwipeEnd: (0, import_primitive.composeEventHandlers)(props.onSwipeEnd, event => {\n        const {\n          x,\n          y\n        } = event.detail.delta;\n        event.currentTarget.setAttribute(\"data-swipe\", \"end\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-y\");\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-end-x\", `${x}px`);\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-end-y\", `${y}px`);\n        setOpen(false);\n      })\n    })\n  });\n});\nToast.displayName = TOAST_NAME;\nvar [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {\n  onClose() {}\n});\nvar ToastImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    type = \"foreground\",\n    duration: durationProp,\n    open,\n    onClose,\n    onEscapeKeyDown,\n    onPause,\n    onResume,\n    onSwipeStart,\n    onSwipeMove,\n    onSwipeCancel,\n    onSwipeEnd,\n    ...toastProps\n  } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [node, setNode] = React.useState(null);\n  const composedRefs = (0, import_react_compose_refs.useComposedRefs)(forwardedRef, node2 => setNode(node2));\n  const pointerStartRef = React.useRef(null);\n  const swipeDeltaRef = React.useRef(null);\n  const duration = durationProp || context.duration;\n  const closeTimerStartTimeRef = React.useRef(0);\n  const closeTimerRemainingTimeRef = React.useRef(duration);\n  const closeTimerRef = React.useRef(0);\n  const {\n    onToastAdd,\n    onToastRemove\n  } = context;\n  const handleClose = (0, import_react_use_callback_ref.useCallbackRef)(() => {\n    const isFocusInToast = node?.contains(document.activeElement);\n    if (isFocusInToast) context.viewport?.focus();\n    onClose();\n  });\n  const startTimer = React.useCallback(duration2 => {\n    if (!duration2 || duration2 === Infinity) return;\n    window.clearTimeout(closeTimerRef.current);\n    closeTimerStartTimeRef.current = (/* @__PURE__ */new Date()).getTime();\n    closeTimerRef.current = window.setTimeout(handleClose, duration2);\n  }, [handleClose]);\n  React.useEffect(() => {\n    const viewport = context.viewport;\n    if (viewport) {\n      const handleResume = () => {\n        startTimer(closeTimerRemainingTimeRef.current);\n        onResume?.();\n      };\n      const handlePause = () => {\n        const elapsedTime = (/* @__PURE__ */new Date()).getTime() - closeTimerStartTimeRef.current;\n        closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;\n        window.clearTimeout(closeTimerRef.current);\n        onPause?.();\n      };\n      viewport.addEventListener(VIEWPORT_PAUSE, handlePause);\n      viewport.addEventListener(VIEWPORT_RESUME, handleResume);\n      return () => {\n        viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);\n        viewport.removeEventListener(VIEWPORT_RESUME, handleResume);\n      };\n    }\n  }, [context.viewport, duration, onPause, onResume, startTimer]);\n  React.useEffect(() => {\n    if (open && !context.isClosePausedRef.current) startTimer(duration);\n  }, [open, duration, context.isClosePausedRef, startTimer]);\n  React.useEffect(() => {\n    onToastAdd();\n    return () => onToastRemove();\n  }, [onToastAdd, onToastRemove]);\n  const announceTextContent = React.useMemo(() => {\n    return node ? getAnnounceTextContent(node) : null;\n  }, [node]);\n  if (!context.viewport) return null;\n  return /* @__PURE__ */(0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {\n    children: [announceTextContent && /* @__PURE__ */(0, import_jsx_runtime.jsx)(ToastAnnounce, {\n      __scopeToast,\n      role: \"status\",\n      \"aria-live\": type === \"foreground\" ? \"assertive\" : \"polite\",\n      \"aria-atomic\": true,\n      children: announceTextContent\n    }), /* @__PURE__ */(0, import_jsx_runtime.jsx)(ToastInteractiveProvider, {\n      scope: __scopeToast,\n      onClose: handleClose,\n      children: ReactDOM.createPortal(/* @__PURE__ */(0, import_jsx_runtime.jsx)(Collection.ItemSlot, {\n        scope: __scopeToast,\n        children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(DismissableLayer.Root, {\n          asChild: true,\n          onEscapeKeyDown: (0, import_primitive.composeEventHandlers)(onEscapeKeyDown, () => {\n            if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();\n            context.isFocusedToastEscapeKeyDownRef.current = false;\n          }),\n          children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_primitive.Primitive.li, {\n            role: \"status\",\n            \"aria-live\": \"off\",\n            \"aria-atomic\": true,\n            tabIndex: 0,\n            \"data-state\": open ? \"open\" : \"closed\",\n            \"data-swipe-direction\": context.swipeDirection,\n            ...toastProps,\n            ref: composedRefs,\n            style: {\n              userSelect: \"none\",\n              touchAction: \"none\",\n              ...props.style\n            },\n            onKeyDown: (0, import_primitive.composeEventHandlers)(props.onKeyDown, event => {\n              if (event.key !== \"Escape\") return;\n              onEscapeKeyDown?.(event.nativeEvent);\n              if (!event.nativeEvent.defaultPrevented) {\n                context.isFocusedToastEscapeKeyDownRef.current = true;\n                handleClose();\n              }\n            }),\n            onPointerDown: (0, import_primitive.composeEventHandlers)(props.onPointerDown, event => {\n              if (event.button !== 0) return;\n              pointerStartRef.current = {\n                x: event.clientX,\n                y: event.clientY\n              };\n            }),\n            onPointerMove: (0, import_primitive.composeEventHandlers)(props.onPointerMove, event => {\n              if (!pointerStartRef.current) return;\n              const x = event.clientX - pointerStartRef.current.x;\n              const y = event.clientY - pointerStartRef.current.y;\n              const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);\n              const isHorizontalSwipe = [\"left\", \"right\"].includes(context.swipeDirection);\n              const clamp = [\"left\", \"up\"].includes(context.swipeDirection) ? Math.min : Math.max;\n              const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;\n              const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;\n              const moveStartBuffer = event.pointerType === \"touch\" ? 10 : 2;\n              const delta = {\n                x: clampedX,\n                y: clampedY\n              };\n              const eventDetail = {\n                originalEvent: event,\n                delta\n              };\n              if (hasSwipeMoveStarted) {\n                swipeDeltaRef.current = delta;\n                handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {\n                  discrete: false\n                });\n              } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {\n                swipeDeltaRef.current = delta;\n                handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {\n                  discrete: false\n                });\n                event.target.setPointerCapture(event.pointerId);\n              } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {\n                pointerStartRef.current = null;\n              }\n            }),\n            onPointerUp: (0, import_primitive.composeEventHandlers)(props.onPointerUp, event => {\n              const delta = swipeDeltaRef.current;\n              const target = event.target;\n              if (target.hasPointerCapture(event.pointerId)) {\n                target.releasePointerCapture(event.pointerId);\n              }\n              swipeDeltaRef.current = null;\n              pointerStartRef.current = null;\n              if (delta) {\n                const toast = event.currentTarget;\n                const eventDetail = {\n                  originalEvent: event,\n                  delta\n                };\n                if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {\n                  handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {\n                    discrete: true\n                  });\n                } else {\n                  handleAndDispatchCustomEvent(TOAST_SWIPE_CANCEL, onSwipeCancel, eventDetail, {\n                    discrete: true\n                  });\n                }\n                toast.addEventListener(\"click\", event2 => event2.preventDefault(), {\n                  once: true\n                });\n              }\n            })\n          })\n        })\n      }), context.viewport)\n    })]\n  });\n});\nvar ToastAnnounce = props => {\n  const {\n    __scopeToast,\n    children,\n    ...announceProps\n  } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [renderAnnounceText, setRenderAnnounceText] = React.useState(false);\n  const [isAnnounced, setIsAnnounced] = React.useState(false);\n  useNextFrame(() => setRenderAnnounceText(true));\n  React.useEffect(() => {\n    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);\n    return () => window.clearTimeout(timer);\n  }, []);\n  return isAnnounced ? null : /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_portal.Portal, {\n    asChild: true,\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_visually_hidden.VisuallyHidden, {\n      ...announceProps,\n      children: renderAnnounceText && /* @__PURE__ */(0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {\n        children: [context.label, \" \", children]\n      })\n    })\n  });\n};\nvar TITLE_NAME = \"ToastTitle\";\nvar ToastTitle = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    ...titleProps\n  } = props;\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_primitive.Primitive.div, {\n    ...titleProps,\n    ref: forwardedRef\n  });\n});\nToastTitle.displayName = TITLE_NAME;\nvar DESCRIPTION_NAME = \"ToastDescription\";\nvar ToastDescription = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    ...descriptionProps\n  } = props;\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_primitive.Primitive.div, {\n    ...descriptionProps,\n    ref: forwardedRef\n  });\n});\nToastDescription.displayName = DESCRIPTION_NAME;\nvar ACTION_NAME = \"ToastAction\";\nvar ToastAction = React.forwardRef((props, forwardedRef) => {\n  const {\n    altText,\n    ...actionProps\n  } = props;\n  if (!altText.trim()) {\n    console.error(`Invalid prop \\`altText\\` supplied to \\`${ACTION_NAME}\\`. Expected non-empty \\`string\\`.`);\n    return null;\n  }\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(ToastAnnounceExclude, {\n    altText,\n    asChild: true,\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(ToastClose, {\n      ...actionProps,\n      ref: forwardedRef\n    })\n  });\n});\nToastAction.displayName = ACTION_NAME;\nvar CLOSE_NAME = \"ToastClose\";\nvar ToastClose = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    ...closeProps\n  } = props;\n  const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(ToastAnnounceExclude, {\n    asChild: true,\n    children: /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_primitive.Primitive.button, {\n      type: \"button\",\n      ...closeProps,\n      ref: forwardedRef,\n      onClick: (0, import_primitive.composeEventHandlers)(props.onClick, interactiveContext.onClose)\n    })\n  });\n});\nToastClose.displayName = CLOSE_NAME;\nvar ToastAnnounceExclude = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    altText,\n    ...announceExcludeProps\n  } = props;\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_primitive.Primitive.div, {\n    \"data-radix-toast-announce-exclude\": \"\",\n    \"data-radix-toast-announce-alt\": altText || void 0,\n    ...announceExcludeProps,\n    ref: forwardedRef\n  });\n});\nfunction getAnnounceTextContent(container) {\n  const textContent = [];\n  const childNodes = Array.from(container.childNodes);\n  childNodes.forEach(node => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);\n    if (isHTMLElement(node)) {\n      const isHidden = node.ariaHidden || node.hidden || node.style.display === \"none\";\n      const isExcluded = node.dataset.radixToastAnnounceExclude === \"\";\n      if (!isHidden) {\n        if (isExcluded) {\n          const altText = node.dataset.radixToastAnnounceAlt;\n          if (altText) textContent.push(altText);\n        } else {\n          textContent.push(...getAnnounceTextContent(node));\n        }\n      }\n    }\n  });\n  return textContent;\n}\nfunction handleAndDispatchCustomEvent(name, handler, detail, {\n  discrete\n}) {\n  const currentTarget = detail.originalEvent.currentTarget;\n  const event = new CustomEvent(name, {\n    bubbles: true,\n    cancelable: true,\n    detail\n  });\n  if (handler) currentTarget.addEventListener(name, handler, {\n    once: true\n  });\n  if (discrete) {\n    (0, import_react_primitive.dispatchDiscreteCustomEvent)(currentTarget, event);\n  } else {\n    currentTarget.dispatchEvent(event);\n  }\n}\nvar isDeltaInDirection = (delta, direction, threshold = 0) => {\n  const deltaX = Math.abs(delta.x);\n  const deltaY = Math.abs(delta.y);\n  const isDeltaX = deltaX > deltaY;\n  if (direction === \"left\" || direction === \"right\") {\n    return isDeltaX && deltaX > threshold;\n  } else {\n    return !isDeltaX && deltaY > threshold;\n  }\n};\nfunction useNextFrame(callback = () => {}) {\n  const fn = (0, import_react_use_callback_ref.useCallbackRef)(callback);\n  (0, import_react_use_layout_effect.useLayoutEffect)(() => {\n    let raf1 = 0;\n    let raf2 = 0;\n    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));\n    return () => {\n      window.cancelAnimationFrame(raf1);\n      window.cancelAnimationFrame(raf2);\n    };\n  }, [fn]);\n}\nfunction isHTMLElement(node) {\n  return node.nodeType === node.ELEMENT_NODE;\n}\nfunction getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n  return nodes;\n}\nfunction focusFirst(candidates) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some(candidate => {\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\nvar Provider = ToastProvider;\nvar Viewport = ToastViewport;\nvar Root2 = Toast;\nvar Title = ToastTitle;\nvar Description = ToastDescription;\nvar Action = ToastAction;\nvar Close = ToastClose;","map":{"version":3,"names":["src_exports","__export","Action","Close","Description","Provider","Root","Root2","Title","Toast","ToastAction","ToastClose","ToastDescription","ToastProvider","ToastTitle","ToastViewport","Viewport","createToastScope","module","exports","__toCommonJS","React","__toESM","require","ReactDOM","import_primitive","import_react_compose_refs","import_react_collection","import_react_context","DismissableLayer","import_react_portal","import_react_presence","import_react_primitive","import_react_use_callback_ref","import_react_use_controllable_state","import_react_use_layout_effect","import_react_visually_hidden","import_jsx_runtime","PROVIDER_NAME","Collection","useCollection","createCollectionScope","createCollection","createToastContext","createContextScope","ToastProviderProvider","useToastProviderContext","props","__scopeToast","label","duration","swipeDirection","swipeThreshold","children","viewport","setViewport","useState","toastCount","setToastCount","isFocusedToastEscapeKeyDownRef","useRef","isClosePausedRef","trim","console","error","jsx","scope","onViewportChange","onToastAdd","useCallback","prevCount","onToastRemove","displayName","VIEWPORT_NAME","VIEWPORT_DEFAULT_HOTKEY","VIEWPORT_PAUSE","VIEWPORT_RESUME","forwardRef","forwardedRef","hotkey","viewportProps","context","getItems","wrapperRef","headFocusProxyRef","tailFocusProxyRef","ref","composedRefs","useComposedRefs","hotkeyLabel","join","replace","hasToasts","useEffect","handleKeyDown","event","isHotkeyPressed","length","every","key","code","current","focus","document","addEventListener","removeEventListener","wrapper","handlePause","pauseEvent","CustomEvent","dispatchEvent","handleResume","resumeEvent","handleFocusOutResume","isFocusMovingOutside","contains","relatedTarget","handlePointerLeaveResume","isFocusInside","activeElement","window","getSortedTabbableCandidates","tabbingDirection","toastItems","tabbableCandidates","map","toastItem","toastNode","toastTabbableCandidates","getTabbableCandidates","reverse","flat","isMetaKey","altKey","ctrlKey","metaKey","isTabKey","focusedElement","isTabbingBackwards","shiftKey","targetIsViewport","target","sortedCandidates","index","findIndex","candidate","focusFirst","slice","preventDefault","jsxs","Branch","role","tabIndex","style","pointerEvents","FocusProxy","onFocusFromOutsideViewport","Slot","Primitive","ol","FOCUS_PROXY_NAME","proxyProps","VisuallyHidden","position","onFocus","prevFocusedElement","isFocusFromOutsideViewport","TOAST_NAME","TOAST_SWIPE_START","TOAST_SWIPE_MOVE","TOAST_SWIPE_CANCEL","TOAST_SWIPE_END","forceMount","open","openProp","defaultOpen","onOpenChange","toastProps","setOpen","useControllableState","prop","defaultProp","onChange","Presence","present","ToastImpl","onClose","onPause","useCallbackRef","onResume","onSwipeStart","composeEventHandlers","currentTarget","setAttribute","onSwipeMove","x","y","detail","delta","setProperty","onSwipeCancel","removeProperty","onSwipeEnd","ToastInteractiveProvider","useToastInteractiveContext","type","durationProp","onEscapeKeyDown","node","setNode","node2","pointerStartRef","swipeDeltaRef","closeTimerStartTimeRef","closeTimerRemainingTimeRef","closeTimerRef","handleClose","isFocusInToast","startTimer","duration2","Infinity","clearTimeout","Date","getTime","setTimeout","elapsedTime","announceTextContent","useMemo","getAnnounceTextContent","Fragment","ToastAnnounce","createPortal","ItemSlot","asChild","li","userSelect","touchAction","onKeyDown","nativeEvent","defaultPrevented","onPointerDown","button","clientX","clientY","onPointerMove","hasSwipeMoveStarted","Boolean","isHorizontalSwipe","includes","clamp","Math","min","max","clampedX","clampedY","moveStartBuffer","pointerType","eventDetail","originalEvent","handleAndDispatchCustomEvent","discrete","isDeltaInDirection","setPointerCapture","pointerId","abs","onPointerUp","hasPointerCapture","releasePointerCapture","toast","event2","once","announceProps","renderAnnounceText","setRenderAnnounceText","isAnnounced","setIsAnnounced","useNextFrame","timer","Portal","TITLE_NAME","titleProps","div","DESCRIPTION_NAME","descriptionProps","ACTION_NAME","altText","actionProps","ToastAnnounceExclude","CLOSE_NAME","closeProps","interactiveContext","onClick","announceExcludeProps","container","textContent","childNodes","Array","from","forEach","nodeType","TEXT_NODE","push","isHTMLElement","isHidden","ariaHidden","hidden","display","isExcluded","dataset","radixToastAnnounceExclude","radixToastAnnounceAlt","name","handler","bubbles","cancelable","dispatchDiscreteCustomEvent","direction","threshold","deltaX","deltaY","isDeltaX","callback","fn","useLayoutEffect","raf1","raf2","requestAnimationFrame","cancelAnimationFrame","ELEMENT_NODE","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","disabled","FILTER_SKIP","FILTER_ACCEPT","nextNode","currentNode","candidates","previouslyFocusedElement","some"],"sources":["/Users/catiecook/Documents/workos/frontend-take-home/client/node_modules/@radix-ui/react-toast/src/index.ts","/Users/catiecook/Documents/workos/frontend-take-home/client/node_modules/@radix-ui/react-toast/src/toast.tsx"],"sourcesContent":["'use client';\nexport {\n  createToastScope,\n  //\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastAction,\n  ToastClose,\n  //\n  Provider,\n  Viewport,\n  Root,\n  Title,\n  Description,\n  Action,\n  Close,\n} from './toast';\nexport type {\n  ToastProviderProps,\n  ToastViewportProps,\n  ToastProps,\n  ToastTitleProps,\n  ToastDescriptionProps,\n  ToastActionProps,\n  ToastCloseProps,\n} from './toast';\n","import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { createContextScope } from '@radix-ui/react-context';\nimport * as DismissableLayer from '@radix-ui/react-dismissable-layer';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { VisuallyHidden } from '@radix-ui/react-visually-hidden';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * ToastProvider\n * -----------------------------------------------------------------------------------------------*/\n\nconst PROVIDER_NAME = 'ToastProvider';\n\nconst [Collection, useCollection, createCollectionScope] = createCollection<ToastElement>('Toast');\n\ntype SwipeDirection = 'up' | 'down' | 'left' | 'right';\ntype ToastProviderContextValue = {\n  label: string;\n  duration: number;\n  swipeDirection: SwipeDirection;\n  swipeThreshold: number;\n  toastCount: number;\n  viewport: ToastViewportElement | null;\n  onViewportChange(viewport: ToastViewportElement): void;\n  onToastAdd(): void;\n  onToastRemove(): void;\n  isFocusedToastEscapeKeyDownRef: React.MutableRefObject<boolean>;\n  isClosePausedRef: React.MutableRefObject<boolean>;\n};\n\ntype ScopedProps<P> = P & { __scopeToast?: Scope };\nconst [createToastContext, createToastScope] = createContextScope('Toast', [createCollectionScope]);\nconst [ToastProviderProvider, useToastProviderContext] =\n  createToastContext<ToastProviderContextValue>(PROVIDER_NAME);\n\ninterface ToastProviderProps {\n  children?: React.ReactNode;\n  /**\n   * An author-localized label for each toast. Used to help screen reader users\n   * associate the interruption with a toast.\n   * @defaultValue 'Notification'\n   */\n  label?: string;\n  /**\n   * Time in milliseconds that each toast should remain visible for.\n   * @defaultValue 5000\n   */\n  duration?: number;\n  /**\n   * Direction of pointer swipe that should close the toast.\n   * @defaultValue 'right'\n   */\n  swipeDirection?: SwipeDirection;\n  /**\n   * Distance in pixels that the swipe must pass before a close is triggered.\n   * @defaultValue 50\n   */\n  swipeThreshold?: number;\n}\n\nconst ToastProvider: React.FC<ToastProviderProps> = (props: ScopedProps<ToastProviderProps>) => {\n  const {\n    __scopeToast,\n    label = 'Notification',\n    duration = 5000,\n    swipeDirection = 'right',\n    swipeThreshold = 50,\n    children,\n  } = props;\n  const [viewport, setViewport] = React.useState<ToastViewportElement | null>(null);\n  const [toastCount, setToastCount] = React.useState(0);\n  const isFocusedToastEscapeKeyDownRef = React.useRef(false);\n  const isClosePausedRef = React.useRef(false);\n\n  if (!label.trim()) {\n    console.error(\n      `Invalid prop \\`label\\` supplied to \\`${PROVIDER_NAME}\\`. Expected non-empty \\`string\\`.`\n    );\n  }\n\n  return (\n    <Collection.Provider scope={__scopeToast}>\n      <ToastProviderProvider\n        scope={__scopeToast}\n        label={label}\n        duration={duration}\n        swipeDirection={swipeDirection}\n        swipeThreshold={swipeThreshold}\n        toastCount={toastCount}\n        viewport={viewport}\n        onViewportChange={setViewport}\n        onToastAdd={React.useCallback(() => setToastCount((prevCount) => prevCount + 1), [])}\n        onToastRemove={React.useCallback(() => setToastCount((prevCount) => prevCount - 1), [])}\n        isFocusedToastEscapeKeyDownRef={isFocusedToastEscapeKeyDownRef}\n        isClosePausedRef={isClosePausedRef}\n      >\n        {children}\n      </ToastProviderProvider>\n    </Collection.Provider>\n  );\n};\n\nToastProvider.displayName = PROVIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastViewport\n * -----------------------------------------------------------------------------------------------*/\n\nconst VIEWPORT_NAME = 'ToastViewport';\nconst VIEWPORT_DEFAULT_HOTKEY = ['F8'];\nconst VIEWPORT_PAUSE = 'toast.viewportPause';\nconst VIEWPORT_RESUME = 'toast.viewportResume';\n\ntype ToastViewportElement = React.ElementRef<typeof Primitive.ol>;\ntype PrimitiveOrderedListProps = React.ComponentPropsWithoutRef<typeof Primitive.ol>;\ninterface ToastViewportProps extends PrimitiveOrderedListProps {\n  /**\n   * The keys to use as the keyboard shortcut that will move focus to the toast viewport.\n   * @defaultValue ['F8']\n   */\n  hotkey?: string[];\n  /**\n   * An author-localized label for the toast viewport to provide context for screen reader users\n   * when navigating page landmarks. The available `{hotkey}` placeholder will be replaced for you.\n   * @defaultValue 'Notifications ({hotkey})'\n   */\n  label?: string;\n}\n\nconst ToastViewport = React.forwardRef<ToastViewportElement, ToastViewportProps>(\n  (props: ScopedProps<ToastViewportProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      hotkey = VIEWPORT_DEFAULT_HOTKEY,\n      label = 'Notifications ({hotkey})',\n      ...viewportProps\n    } = props;\n    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);\n    const getItems = useCollection(__scopeToast);\n    const wrapperRef = React.useRef<HTMLDivElement>(null);\n    const headFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const tailFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const ref = React.useRef<ToastViewportElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n    const hotkeyLabel = hotkey.join('+').replace(/Key/g, '').replace(/Digit/g, '');\n    const hasToasts = context.toastCount > 0;\n\n    React.useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        // we use `event.code` as it is consistent regardless of meta keys that were pressed.\n        // for example, `event.key` for `Control+Alt+t` is `†` and `t !== †`\n        const isHotkeyPressed =\n          hotkey.length !== 0 && hotkey.every((key) => (event as any)[key] || event.code === key);\n        if (isHotkeyPressed) ref.current?.focus();\n      };\n      document.addEventListener('keydown', handleKeyDown);\n      return () => document.removeEventListener('keydown', handleKeyDown);\n    }, [hotkey]);\n\n    React.useEffect(() => {\n      const wrapper = wrapperRef.current;\n      const viewport = ref.current;\n      if (hasToasts && wrapper && viewport) {\n        const handlePause = () => {\n          if (!context.isClosePausedRef.current) {\n            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);\n            viewport.dispatchEvent(pauseEvent);\n            context.isClosePausedRef.current = true;\n          }\n        };\n\n        const handleResume = () => {\n          if (context.isClosePausedRef.current) {\n            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);\n            viewport.dispatchEvent(resumeEvent);\n            context.isClosePausedRef.current = false;\n          }\n        };\n\n        const handleFocusOutResume = (event: FocusEvent) => {\n          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget as HTMLElement);\n          if (isFocusMovingOutside) handleResume();\n        };\n\n        const handlePointerLeaveResume = () => {\n          const isFocusInside = wrapper.contains(document.activeElement);\n          if (!isFocusInside) handleResume();\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        wrapper.addEventListener('focusin', handlePause);\n        wrapper.addEventListener('focusout', handleFocusOutResume);\n        wrapper.addEventListener('pointermove', handlePause);\n        wrapper.addEventListener('pointerleave', handlePointerLeaveResume);\n        window.addEventListener('blur', handlePause);\n        window.addEventListener('focus', handleResume);\n        return () => {\n          wrapper.removeEventListener('focusin', handlePause);\n          wrapper.removeEventListener('focusout', handleFocusOutResume);\n          wrapper.removeEventListener('pointermove', handlePause);\n          wrapper.removeEventListener('pointerleave', handlePointerLeaveResume);\n          window.removeEventListener('blur', handlePause);\n          window.removeEventListener('focus', handleResume);\n        };\n      }\n    }, [hasToasts, context.isClosePausedRef]);\n\n    const getSortedTabbableCandidates = React.useCallback(\n      ({ tabbingDirection }: { tabbingDirection: 'forwards' | 'backwards' }) => {\n        const toastItems = getItems();\n        const tabbableCandidates = toastItems.map((toastItem) => {\n          const toastNode = toastItem.ref.current!;\n          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];\n          return tabbingDirection === 'forwards'\n            ? toastTabbableCandidates\n            : toastTabbableCandidates.reverse();\n        });\n        return (\n          tabbingDirection === 'forwards' ? tabbableCandidates.reverse() : tabbableCandidates\n        ).flat();\n      },\n      [getItems]\n    );\n\n    React.useEffect(() => {\n      const viewport = ref.current;\n      // We programmatically manage tabbing as we are unable to influence\n      // the source order with portals, this allows us to reverse the\n      // tab order so that it runs from most recent toast to least\n      if (viewport) {\n        const handleKeyDown = (event: KeyboardEvent) => {\n          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n          const isTabKey = event.key === 'Tab' && !isMetaKey;\n\n          if (isTabKey) {\n            const focusedElement = document.activeElement;\n            const isTabbingBackwards = event.shiftKey;\n            const targetIsViewport = event.target === viewport;\n\n            // If we're back tabbing after jumping to the viewport then we simply\n            // proxy focus out to the preceding document\n            if (targetIsViewport && isTabbingBackwards) {\n              headFocusProxyRef.current?.focus();\n              return;\n            }\n\n            const tabbingDirection = isTabbingBackwards ? 'backwards' : 'forwards';\n            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });\n            const index = sortedCandidates.findIndex((candidate) => candidate === focusedElement);\n            if (focusFirst(sortedCandidates.slice(index + 1))) {\n              event.preventDefault();\n            } else {\n              // If we can't focus that means we're at the edges so we\n              // proxy to the corresponding exit point and let the browser handle\n              // tab/shift+tab keypress and implicitly pass focus to the next valid element in the document\n              isTabbingBackwards\n                ? headFocusProxyRef.current?.focus()\n                : tailFocusProxyRef.current?.focus();\n            }\n          }\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        viewport.addEventListener('keydown', handleKeyDown);\n        return () => viewport.removeEventListener('keydown', handleKeyDown);\n      }\n    }, [getItems, getSortedTabbableCandidates]);\n\n    return (\n      <DismissableLayer.Branch\n        ref={wrapperRef}\n        role=\"region\"\n        aria-label={label.replace('{hotkey}', hotkeyLabel)}\n        // Ensure virtual cursor from landmarks menus triggers focus/blur for pause/resume\n        tabIndex={-1}\n        // incase list has size when empty (e.g. padding), we remove pointer events so\n        // it doesn't prevent interactions with page elements that it overlays\n        style={{ pointerEvents: hasToasts ? undefined : 'none' }}\n      >\n        {hasToasts && (\n          <FocusProxy\n            ref={headFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'forwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n        {/**\n         * tabindex on the the list so that it can be focused when items are removed. we focus\n         * the list instead of the viewport so it announces number of items remaining.\n         */}\n        <Collection.Slot scope={__scopeToast}>\n          <Primitive.ol tabIndex={-1} {...viewportProps} ref={composedRefs} />\n        </Collection.Slot>\n        {hasToasts && (\n          <FocusProxy\n            ref={tailFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'backwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n      </DismissableLayer.Branch>\n    );\n  }\n);\n\nToastViewport.displayName = VIEWPORT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_PROXY_NAME = 'ToastFocusProxy';\n\ntype FocusProxyElement = React.ElementRef<typeof VisuallyHidden>;\ntype VisuallyHiddenProps = React.ComponentPropsWithoutRef<typeof VisuallyHidden>;\ninterface FocusProxyProps extends VisuallyHiddenProps {\n  onFocusFromOutsideViewport(): void;\n}\n\nconst FocusProxy = React.forwardRef<FocusProxyElement, ScopedProps<FocusProxyProps>>(\n  (props, forwardedRef) => {\n    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;\n    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);\n\n    return (\n      <VisuallyHidden\n        aria-hidden\n        tabIndex={0}\n        {...proxyProps}\n        ref={forwardedRef}\n        // Avoid page scrolling when focus is on the focus proxy\n        style={{ position: 'fixed' }}\n        onFocus={(event) => {\n          const prevFocusedElement = event.relatedTarget as HTMLElement | null;\n          const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);\n          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();\n        }}\n      />\n    );\n  }\n);\n\nFocusProxy.displayName = FOCUS_PROXY_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Toast\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOAST_NAME = 'Toast';\nconst TOAST_SWIPE_START = 'toast.swipeStart';\nconst TOAST_SWIPE_MOVE = 'toast.swipeMove';\nconst TOAST_SWIPE_CANCEL = 'toast.swipeCancel';\nconst TOAST_SWIPE_END = 'toast.swipeEnd';\n\ntype ToastElement = ToastImplElement;\ninterface ToastProps extends Omit<ToastImplProps, keyof ToastImplPrivateProps> {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst Toast = React.forwardRef<ToastElement, ToastProps>(\n  (props: ScopedProps<ToastProps>, forwardedRef) => {\n    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;\n    const [open = true, setOpen] = useControllableState({\n      prop: openProp,\n      defaultProp: defaultOpen,\n      onChange: onOpenChange,\n    });\n    return (\n      <Presence present={forceMount || open}>\n        <ToastImpl\n          open={open}\n          {...toastProps}\n          ref={forwardedRef}\n          onClose={() => setOpen(false)}\n          onPause={useCallbackRef(props.onPause)}\n          onResume={useCallbackRef(props.onResume)}\n          onSwipeStart={composeEventHandlers(props.onSwipeStart, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'start');\n          })}\n          onSwipeMove={composeEventHandlers(props.onSwipeMove, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'move');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-y', `${y}px`);\n          })}\n          onSwipeCancel={composeEventHandlers(props.onSwipeCancel, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'cancel');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-y');\n          })}\n          onSwipeEnd={composeEventHandlers(props.onSwipeEnd, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'end');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-y', `${y}px`);\n            setOpen(false);\n          })}\n        />\n      </Presence>\n    );\n  }\n);\n\nToast.displayName = TOAST_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype SwipeEvent = { currentTarget: EventTarget & ToastElement } & Omit<\n  CustomEvent<{ originalEvent: React.PointerEvent; delta: { x: number; y: number } }>,\n  'currentTarget'\n>;\n\nconst [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {\n  onClose() {},\n});\n\ntype ToastImplElement = React.ElementRef<typeof Primitive.li>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer.Root>;\ntype ToastImplPrivateProps = { open: boolean; onClose(): void };\ntype PrimitiveListItemProps = React.ComponentPropsWithoutRef<typeof Primitive.li>;\ninterface ToastImplProps extends ToastImplPrivateProps, PrimitiveListItemProps {\n  type?: 'foreground' | 'background';\n  /**\n   * Time in milliseconds that toast should remain visible for. Overrides value\n   * given to `ToastProvider`.\n   */\n  duration?: number;\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  onPause?(): void;\n  onResume?(): void;\n  onSwipeStart?(event: SwipeEvent): void;\n  onSwipeMove?(event: SwipeEvent): void;\n  onSwipeCancel?(event: SwipeEvent): void;\n  onSwipeEnd?(event: SwipeEvent): void;\n}\n\nconst ToastImpl = React.forwardRef<ToastImplElement, ToastImplProps>(\n  (props: ScopedProps<ToastImplProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      type = 'foreground',\n      duration: durationProp,\n      open,\n      onClose,\n      onEscapeKeyDown,\n      onPause,\n      onResume,\n      onSwipeStart,\n      onSwipeMove,\n      onSwipeCancel,\n      onSwipeEnd,\n      ...toastProps\n    } = props;\n    const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n    const [node, setNode] = React.useState<ToastImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const pointerStartRef = React.useRef<{ x: number; y: number } | null>(null);\n    const swipeDeltaRef = React.useRef<{ x: number; y: number } | null>(null);\n    const duration = durationProp || context.duration;\n    const closeTimerStartTimeRef = React.useRef(0);\n    const closeTimerRemainingTimeRef = React.useRef(duration);\n    const closeTimerRef = React.useRef(0);\n    const { onToastAdd, onToastRemove } = context;\n    const handleClose = useCallbackRef(() => {\n      // focus viewport if focus is within toast to read the remaining toast\n      // count to SR users and ensure focus isn't lost\n      const isFocusInToast = node?.contains(document.activeElement);\n      if (isFocusInToast) context.viewport?.focus();\n      onClose();\n    });\n\n    const startTimer = React.useCallback(\n      (duration: number) => {\n        if (!duration || duration === Infinity) return;\n        window.clearTimeout(closeTimerRef.current);\n        closeTimerStartTimeRef.current = new Date().getTime();\n        closeTimerRef.current = window.setTimeout(handleClose, duration);\n      },\n      [handleClose]\n    );\n\n    React.useEffect(() => {\n      const viewport = context.viewport;\n      if (viewport) {\n        const handleResume = () => {\n          startTimer(closeTimerRemainingTimeRef.current);\n          onResume?.();\n        };\n        const handlePause = () => {\n          const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.current;\n          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;\n          window.clearTimeout(closeTimerRef.current);\n          onPause?.();\n        };\n        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);\n        viewport.addEventListener(VIEWPORT_RESUME, handleResume);\n        return () => {\n          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);\n          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);\n        };\n      }\n    }, [context.viewport, duration, onPause, onResume, startTimer]);\n\n    // start timer when toast opens or duration changes.\n    // we include `open` in deps because closed !== unmounted when animating\n    // so it could reopen before being completely unmounted\n    React.useEffect(() => {\n      if (open && !context.isClosePausedRef.current) startTimer(duration);\n    }, [open, duration, context.isClosePausedRef, startTimer]);\n\n    React.useEffect(() => {\n      onToastAdd();\n      return () => onToastRemove();\n    }, [onToastAdd, onToastRemove]);\n\n    const announceTextContent = React.useMemo(() => {\n      return node ? getAnnounceTextContent(node) : null;\n    }, [node]);\n\n    if (!context.viewport) return null;\n\n    return (\n      <>\n        {announceTextContent && (\n          <ToastAnnounce\n            __scopeToast={__scopeToast}\n            // Toasts are always role=status to avoid stuttering issues with role=alert in SRs.\n            role=\"status\"\n            aria-live={type === 'foreground' ? 'assertive' : 'polite'}\n            aria-atomic\n          >\n            {announceTextContent}\n          </ToastAnnounce>\n        )}\n\n        <ToastInteractiveProvider scope={__scopeToast} onClose={handleClose}>\n          {ReactDOM.createPortal(\n            <Collection.ItemSlot scope={__scopeToast}>\n              <DismissableLayer.Root\n                asChild\n                onEscapeKeyDown={composeEventHandlers(onEscapeKeyDown, () => {\n                  if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();\n                  context.isFocusedToastEscapeKeyDownRef.current = false;\n                })}\n              >\n                <Primitive.li\n                  // Ensure toasts are announced as status list or status when focused\n                  role=\"status\"\n                  aria-live=\"off\"\n                  aria-atomic\n                  tabIndex={0}\n                  data-state={open ? 'open' : 'closed'}\n                  data-swipe-direction={context.swipeDirection}\n                  {...toastProps}\n                  ref={composedRefs}\n                  style={{ userSelect: 'none', touchAction: 'none', ...props.style }}\n                  onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                    if (event.key !== 'Escape') return;\n                    onEscapeKeyDown?.(event.nativeEvent);\n                    if (!event.nativeEvent.defaultPrevented) {\n                      context.isFocusedToastEscapeKeyDownRef.current = true;\n                      handleClose();\n                    }\n                  })}\n                  onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n                    if (event.button !== 0) return;\n                    pointerStartRef.current = { x: event.clientX, y: event.clientY };\n                  })}\n                  onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n                    if (!pointerStartRef.current) return;\n                    const x = event.clientX - pointerStartRef.current.x;\n                    const y = event.clientY - pointerStartRef.current.y;\n                    const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);\n                    const isHorizontalSwipe = ['left', 'right'].includes(context.swipeDirection);\n                    const clamp = ['left', 'up'].includes(context.swipeDirection)\n                      ? Math.min\n                      : Math.max;\n                    const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;\n                    const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;\n                    const moveStartBuffer = event.pointerType === 'touch' ? 10 : 2;\n                    const delta = { x: clampedX, y: clampedY };\n                    const eventDetail = { originalEvent: event, delta };\n                    if (hasSwipeMoveStarted) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {\n                        discrete: false,\n                      });\n                    } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {\n                        discrete: false,\n                      });\n                      (event.target as HTMLElement).setPointerCapture(event.pointerId);\n                    } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {\n                      // User is swiping in wrong direction so we disable swipe gesture\n                      // for the current pointer down interaction\n                      pointerStartRef.current = null;\n                    }\n                  })}\n                  onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n                    const delta = swipeDeltaRef.current;\n                    const target = event.target as HTMLElement;\n                    if (target.hasPointerCapture(event.pointerId)) {\n                      target.releasePointerCapture(event.pointerId);\n                    }\n                    swipeDeltaRef.current = null;\n                    pointerStartRef.current = null;\n                    if (delta) {\n                      const toast = event.currentTarget;\n                      const eventDetail = { originalEvent: event, delta };\n                      if (\n                        isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)\n                      ) {\n                        handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {\n                          discrete: true,\n                        });\n                      } else {\n                        handleAndDispatchCustomEvent(\n                          TOAST_SWIPE_CANCEL,\n                          onSwipeCancel,\n                          eventDetail,\n                          {\n                            discrete: true,\n                          }\n                        );\n                      }\n                      // Prevent click event from triggering on items within the toast when\n                      // pointer up is part of a swipe gesture\n                      toast.addEventListener('click', (event) => event.preventDefault(), {\n                        once: true,\n                      });\n                    }\n                  })}\n                />\n              </DismissableLayer.Root>\n            </Collection.ItemSlot>,\n            context.viewport\n          )}\n        </ToastInteractiveProvider>\n      </>\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\ninterface ToastAnnounceProps\n  extends Omit<React.ComponentPropsWithoutRef<'div'>, 'children'>,\n    ScopedProps<{ children: string[] }> {}\n\nconst ToastAnnounce: React.FC<ToastAnnounceProps> = (props: ScopedProps<ToastAnnounceProps>) => {\n  const { __scopeToast, children, ...announceProps } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [renderAnnounceText, setRenderAnnounceText] = React.useState(false);\n  const [isAnnounced, setIsAnnounced] = React.useState(false);\n\n  // render text content in the next frame to ensure toast is announced in NVDA\n  useNextFrame(() => setRenderAnnounceText(true));\n\n  // cleanup after announcing\n  React.useEffect(() => {\n    const timer = window.setTimeout(() => setIsAnnounced(true), 1000);\n    return () => window.clearTimeout(timer);\n  }, []);\n\n  return isAnnounced ? null : (\n    <Portal asChild>\n      <VisuallyHidden {...announceProps}>\n        {renderAnnounceText && (\n          <>\n            {context.label} {children}\n          </>\n        )}\n      </VisuallyHidden>\n    </Portal>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * ToastTitle\n * -----------------------------------------------------------------------------------------------*/\n\nconst TITLE_NAME = 'ToastTitle';\n\ntype ToastTitleElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface ToastTitleProps extends PrimitiveDivProps {}\n\nconst ToastTitle = React.forwardRef<ToastTitleElement, ToastTitleProps>(\n  (props: ScopedProps<ToastTitleProps>, forwardedRef) => {\n    const { __scopeToast, ...titleProps } = props;\n    return <Primitive.div {...titleProps} ref={forwardedRef} />;\n  }\n);\n\nToastTitle.displayName = TITLE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastDescription\n * -----------------------------------------------------------------------------------------------*/\n\nconst DESCRIPTION_NAME = 'ToastDescription';\n\ntype ToastDescriptionElement = React.ElementRef<typeof Primitive.div>;\ninterface ToastDescriptionProps extends PrimitiveDivProps {}\n\nconst ToastDescription = React.forwardRef<ToastDescriptionElement, ToastDescriptionProps>(\n  (props: ScopedProps<ToastDescriptionProps>, forwardedRef) => {\n    const { __scopeToast, ...descriptionProps } = props;\n    return <Primitive.div {...descriptionProps} ref={forwardedRef} />;\n  }\n);\n\nToastDescription.displayName = DESCRIPTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastAction\n * -----------------------------------------------------------------------------------------------*/\n\nconst ACTION_NAME = 'ToastAction';\n\ntype ToastActionElement = ToastCloseElement;\ninterface ToastActionProps extends ToastCloseProps {\n  /**\n   * A short description for an alternate way to carry out the action. For screen reader users\n   * who will not be able to navigate to the button easily/quickly.\n   * @example <ToastAction altText=\"Goto account settings to upgrade\">Upgrade</ToastAction>\n   * @example <ToastAction altText=\"Undo (Alt+U)\">Undo</ToastAction>\n   */\n  altText: string;\n}\n\nconst ToastAction = React.forwardRef<ToastActionElement, ToastActionProps>(\n  (props: ScopedProps<ToastActionProps>, forwardedRef) => {\n    const { altText, ...actionProps } = props;\n\n    if (!altText.trim()) {\n      console.error(\n        `Invalid prop \\`altText\\` supplied to \\`${ACTION_NAME}\\`. Expected non-empty \\`string\\`.`\n      );\n      return null;\n    }\n\n    return (\n      <ToastAnnounceExclude altText={altText} asChild>\n        <ToastClose {...actionProps} ref={forwardedRef} />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastAction.displayName = ACTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastClose\n * -----------------------------------------------------------------------------------------------*/\n\nconst CLOSE_NAME = 'ToastClose';\n\ntype ToastCloseElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface ToastCloseProps extends PrimitiveButtonProps {}\n\nconst ToastClose = React.forwardRef<ToastCloseElement, ToastCloseProps>(\n  (props: ScopedProps<ToastCloseProps>, forwardedRef) => {\n    const { __scopeToast, ...closeProps } = props;\n    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);\n\n    return (\n      <ToastAnnounceExclude asChild>\n        <Primitive.button\n          type=\"button\"\n          {...closeProps}\n          ref={forwardedRef}\n          onClick={composeEventHandlers(props.onClick, interactiveContext.onClose)}\n        />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastClose.displayName = CLOSE_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype ToastAnnounceExcludeElement = React.ElementRef<typeof Primitive.div>;\ninterface ToastAnnounceExcludeProps extends PrimitiveDivProps {\n  altText?: string;\n}\n\nconst ToastAnnounceExclude = React.forwardRef<\n  ToastAnnounceExcludeElement,\n  ToastAnnounceExcludeProps\n>((props: ScopedProps<ToastAnnounceExcludeProps>, forwardedRef) => {\n  const { __scopeToast, altText, ...announceExcludeProps } = props;\n\n  return (\n    <Primitive.div\n      data-radix-toast-announce-exclude=\"\"\n      data-radix-toast-announce-alt={altText || undefined}\n      {...announceExcludeProps}\n      ref={forwardedRef}\n    />\n  );\n});\n\nfunction getAnnounceTextContent(container: HTMLElement) {\n  const textContent: string[] = [];\n  const childNodes = Array.from(container.childNodes);\n\n  childNodes.forEach((node) => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);\n    if (isHTMLElement(node)) {\n      const isHidden = node.ariaHidden || node.hidden || node.style.display === 'none';\n      const isExcluded = node.dataset.radixToastAnnounceExclude === '';\n\n      if (!isHidden) {\n        if (isExcluded) {\n          const altText = node.dataset.radixToastAnnounceAlt;\n          if (altText) textContent.push(altText);\n        } else {\n          textContent.push(...getAnnounceTextContent(node));\n        }\n      }\n    }\n  });\n\n  // We return a collection of text rather than a single concatenated string.\n  // This allows SR VO to naturally pause break between nodes while announcing.\n  return textContent;\n}\n\n/* ---------------------------------------------------------------------------------------------- */\n\nfunction handleAndDispatchCustomEvent<\n  E extends CustomEvent,\n  ReactEvent extends React.SyntheticEvent,\n>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: ReactEvent } & (E extends CustomEvent<infer D> ? D : never),\n  { discrete }: { discrete: boolean }\n) {\n  const currentTarget = detail.originalEvent.currentTarget as HTMLElement;\n  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });\n  if (handler) currentTarget.addEventListener(name, handler as EventListener, { once: true });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(currentTarget, event);\n  } else {\n    currentTarget.dispatchEvent(event);\n  }\n}\n\nconst isDeltaInDirection = (\n  delta: { x: number; y: number },\n  direction: SwipeDirection,\n  threshold = 0\n) => {\n  const deltaX = Math.abs(delta.x);\n  const deltaY = Math.abs(delta.y);\n  const isDeltaX = deltaX > deltaY;\n  if (direction === 'left' || direction === 'right') {\n    return isDeltaX && deltaX > threshold;\n  } else {\n    return !isDeltaX && deltaY > threshold;\n  }\n};\n\nfunction useNextFrame(callback = () => {}) {\n  const fn = useCallbackRef(callback);\n  useLayoutEffect(() => {\n    let raf1 = 0;\n    let raf2 = 0;\n    raf1 = window.requestAnimationFrame(() => (raf2 = window.requestAnimationFrame(fn)));\n    return () => {\n      window.cancelAnimationFrame(raf1);\n      window.cancelAnimationFrame(raf2);\n    };\n  }, [fn]);\n}\n\nfunction isHTMLElement(node: any): node is HTMLElement {\n  return node.nodeType === node.ELEMENT_NODE;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some((candidate) => {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\n\nconst Provider = ToastProvider;\nconst Viewport = ToastViewport;\nconst Root = Toast;\nconst Title = ToastTitle;\nconst Description = ToastDescription;\nconst Action = ToastAction;\nconst Close = ToastClose;\n\nexport {\n  createToastScope,\n  //\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastAction,\n  ToastClose,\n  //\n  Provider,\n  Viewport,\n  Root,\n  Title,\n  Description,\n  Action,\n  Close,\n};\nexport type {\n  ToastProviderProps,\n  ToastViewportProps,\n  ToastProps,\n  ToastTitleProps,\n  ToastDescriptionProps,\n  ToastActionProps,\n  ToastCloseProps,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}