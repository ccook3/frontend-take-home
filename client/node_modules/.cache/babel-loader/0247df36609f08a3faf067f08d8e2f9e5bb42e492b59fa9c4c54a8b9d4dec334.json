{"ast":null,"code":"\"use strict\";\n\"use client\";\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n// If the importer is in node compatibility mode or this is not an ESM\n// file that has been converted to a CommonJS file using a Babel-\n// compatible transform (i.e. \"__esModule\" has not been set), then set\n// \"default\" to the CommonJS \"module.exports\" for node compatibility.\nisNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// packages/react/focus-scope/src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  FocusScope: () => FocusScope,\n  Root: () => Root\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// packages/react/focus-scope/src/focus-scope.tsx\nvar React = __toESM(require(\"react\"));\nvar import_react_compose_refs = require(\"@radix-ui/react-compose-refs\");\nvar import_react_primitive = require(\"@radix-ui/react-primitive\");\nvar import_react_use_callback_ref = require(\"@radix-ui/react-use-callback-ref\");\nvar import_jsx_runtime = require(\"react/jsx-runtime\");\nvar AUTOFOCUS_ON_MOUNT = \"focusScope.autoFocusOnMount\";\nvar AUTOFOCUS_ON_UNMOUNT = \"focusScope.autoFocusOnUnmount\";\nvar EVENT_OPTIONS = {\n  bubbles: false,\n  cancelable: true\n};\nvar FOCUS_SCOPE_NAME = \"FocusScope\";\nvar FocusScope = React.forwardRef((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState(null);\n  const onMountAutoFocus = (0, import_react_use_callback_ref.useCallbackRef)(onMountAutoFocusProp);\n  const onUnmountAutoFocus = (0, import_react_use_callback_ref.useCallbackRef)(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef(null);\n  const composedRefs = (0, import_react_compose_refs.useComposedRefs)(forwardedRef, node => setContainer(node));\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    }\n  }).current;\n  React.useEffect(() => {\n    if (trapped) {\n      let handleFocusIn2 = function (event) {\n          if (focusScope.paused || !container) return;\n          const target = event.target;\n          if (container.contains(target)) {\n            lastFocusedElementRef.current = target;\n          } else {\n            focus(lastFocusedElementRef.current, {\n              select: true\n            });\n          }\n        },\n        handleFocusOut2 = function (event) {\n          if (focusScope.paused || !container) return;\n          const relatedTarget = event.relatedTarget;\n          if (relatedTarget === null) return;\n          if (!container.contains(relatedTarget)) {\n            focus(lastFocusedElementRef.current, {\n              select: true\n            });\n          }\n        },\n        handleMutations2 = function (mutations) {\n          const focusedElement = document.activeElement;\n          if (focusedElement !== document.body) return;\n          for (const mutation of mutations) {\n            if (mutation.removedNodes.length > 0) focus(container);\n          }\n        };\n      var handleFocusIn = handleFocusIn2,\n        handleFocusOut = handleFocusOut2,\n        handleMutations = handleMutations2;\n      document.addEventListener(\"focusin\", handleFocusIn2);\n      document.addEventListener(\"focusout\", handleFocusOut2);\n      const mutationObserver = new MutationObserver(handleMutations2);\n      if (container) mutationObserver.observe(container, {\n        childList: true,\n        subtree: true\n      });\n      return () => {\n        document.removeEventListener(\"focusin\", handleFocusIn2);\n        document.removeEventListener(\"focusout\", handleFocusOut2);\n        mutationObserver.disconnect();\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), {\n            select: true\n          });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, {\n              select: true\n            });\n          }\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n  const handleKeyDown = React.useCallback(event => {\n    if (!loop && !trapped) return;\n    if (focusScope.paused) return;\n    const isTabKey = event.key === \"Tab\" && !event.altKey && !event.ctrlKey && !event.metaKey;\n    const focusedElement = document.activeElement;\n    if (isTabKey && focusedElement) {\n      const container2 = event.currentTarget;\n      const [first, last] = getTabbableEdges(container2);\n      const hasTabbableElementsInside = first && last;\n      if (!hasTabbableElementsInside) {\n        if (focusedElement === container2) event.preventDefault();\n      } else {\n        if (!event.shiftKey && focusedElement === last) {\n          event.preventDefault();\n          if (loop) focus(first, {\n            select: true\n          });\n        } else if (event.shiftKey && focusedElement === first) {\n          event.preventDefault();\n          if (loop) focus(last, {\n            select: true\n          });\n        }\n      }\n    }\n  }, [loop, trapped, focusScope.paused]);\n  return /* @__PURE__ */(0, import_jsx_runtime.jsx)(import_react_primitive.Primitive.div, {\n    tabIndex: -1,\n    ...scopeProps,\n    ref: composedRefs,\n    onKeyDown: handleKeyDown\n  });\n});\nFocusScope.displayName = FOCUS_SCOPE_NAME;\nfunction focusFirst(candidates, {\n  select = false\n} = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, {\n      select\n    });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\nfunction getTabbableEdges(container) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last];\n}\nfunction getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n  return nodes;\n}\nfunction findVisible(elements, container) {\n  for (const element of elements) {\n    if (!isHidden(element, {\n      upTo: container\n    })) return element;\n  }\n}\nfunction isHidden(node, {\n  upTo\n}) {\n  if (getComputedStyle(node).visibility === \"hidden\") return true;\n  while (node) {\n    if (upTo !== void 0 && node === upTo) return false;\n    if (getComputedStyle(node).display === \"none\") return true;\n    node = node.parentElement;\n  }\n  return false;\n}\nfunction isSelectableInput(element) {\n  return element instanceof HTMLInputElement && \"select\" in element;\n}\nfunction focus(element, {\n  select = false\n} = {}) {\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    element.focus({\n      preventScroll: true\n    });\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select) element.select();\n  }\n}\nvar focusScopesStack = createFocusScopesStack();\nfunction createFocusScopesStack() {\n  let stack = [];\n  return {\n    add(focusScope) {\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n    remove(focusScope) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    }\n  };\n}\nfunction arrayRemove(array, item) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\nfunction removeLinks(items) {\n  return items.filter(item => item.tagName !== \"A\");\n}\nvar Root = FocusScope;","map":{"version":3,"names":["src_exports","__export","FocusScope","Root","module","exports","__toCommonJS","React","__toESM","require","import_react_compose_refs","import_react_primitive","import_react_use_callback_ref","import_jsx_runtime","AUTOFOCUS_ON_MOUNT","AUTOFOCUS_ON_UNMOUNT","EVENT_OPTIONS","bubbles","cancelable","FOCUS_SCOPE_NAME","forwardRef","props","forwardedRef","loop","trapped","onMountAutoFocus","onMountAutoFocusProp","onUnmountAutoFocus","onUnmountAutoFocusProp","scopeProps","container","setContainer","useState","useCallbackRef","lastFocusedElementRef","useRef","composedRefs","useComposedRefs","node","focusScope","paused","pause","resume","current","useEffect","handleFocusIn2","handleFocusIn","event","target","contains","focus","select","handleFocusOut2","handleFocusOut","relatedTarget","handleMutations2","handleMutations","mutations","focusedElement","document","activeElement","body","mutation","removedNodes","length","addEventListener","mutationObserver","MutationObserver","observe","childList","subtree","removeEventListener","disconnect","focusScopesStack","add","previouslyFocusedElement","hasFocusedCandidate","mountEvent","CustomEvent","dispatchEvent","defaultPrevented","focusFirst","removeLinks","getTabbableCandidates","setTimeout","unmountEvent","remove","handleKeyDown","useCallback","isTabKey","key","altKey","ctrlKey","metaKey","container2","currentTarget","first","last","getTabbableEdges","hasTabbableElementsInside","preventDefault","shiftKey","jsx","Primitive","div","tabIndex","ref","onKeyDown","displayName","candidates","candidate","findVisible","reverse","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","type","disabled","hidden","FILTER_SKIP","FILTER_ACCEPT","nextNode","push","currentNode","elements","element","isHidden","upTo","getComputedStyle","visibility","display","parentElement","isSelectableInput","HTMLInputElement","preventScroll","createFocusScopesStack","stack","activeFocusScope","arrayRemove","unshift","array","item","updatedArray","index","indexOf","splice","items","filter"],"sources":["/Users/catiecook/Documents/workos/frontend-take-home/client/node_modules/@radix-ui/react-focus-scope/src/index.ts","/Users/catiecook/Documents/workos/frontend-take-home/client/node_modules/@radix-ui/react-focus-scope/src/focus-scope.tsx"],"sourcesContent":["'use client';\nexport {\n  FocusScope,\n  //\n  Root,\n} from './focus-scope';\nexport type { FocusScopeProps } from './focus-scope';\n","import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\nconst AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\ntype FocusableTarget = HTMLElement | { focus(): void };\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_SCOPE_NAME = 'FocusScope';\n\ntype FocusScopeElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface FocusScopeProps extends PrimitiveDivProps {\n  /**\n   * When `true`, tabbing from last item will focus first tabbable\n   * and shift+tab from first item will focus last tababble.\n   * @defaultValue false\n   */\n  loop?: boolean;\n\n  /**\n   * When `true`, focus cannot escape the focus scope via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapped?: boolean;\n\n  /**\n   * Event handler called when auto-focusing on mount.\n   * Can be prevented.\n   */\n  onMountAutoFocus?: (event: Event) => void;\n\n  /**\n   * Event handler called when auto-focusing on unmount.\n   * Can be prevented.\n   */\n  onUnmountAutoFocus?: (event: Event) => void;\n}\n\nconst FocusScope = React.forwardRef<FocusScopeElement, FocusScopeProps>((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState<HTMLElement | null>(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef<HTMLElement | null>(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));\n\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    },\n  }).current;\n\n  // Takes care of trapping focus if focus is moved outside programmatically for example\n  React.useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const target = event.target as HTMLElement | null;\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      function handleFocusOut(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const relatedTarget = event.relatedTarget as HTMLElement | null;\n\n        // A `focusout` event with a `null` `relatedTarget` will happen in at least two cases:\n        //\n        // 1. When the user switches app/tabs/windows/the browser itself loses focus.\n        // 2. In Google Chrome, when the focused element is removed from the DOM.\n        //\n        // We let the browser do its thing here because:\n        //\n        // 1. The browser already keeps a memory of what's focused for when the page gets refocused.\n        // 2. In Google Chrome, if we try to focus the deleted focused element (as per below), it\n        //    throws the CPU to 100%, so we avoid doing anything for this reason here too.\n        if (relatedTarget === null) return;\n\n        // If the focus has moved to an actual legitimate element (`relatedTarget !== null`)\n        // that is outside the container, we move focus to the last valid focused element inside.\n        if (!container.contains(relatedTarget)) {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      // When the focused element gets removed from the DOM, browsers move focus\n      // back to the document.body. In this case, we move focus to the container\n      // to keep focus trapped correctly.\n      function handleMutations(mutations: MutationRecord[]) {\n        const focusedElement = document.activeElement as HTMLElement | null;\n        if (focusedElement !== document.body) return;\n        for (const mutation of mutations) {\n          if (mutation.removedNodes.length > 0) focus(container);\n        }\n      }\n\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      const mutationObserver = new MutationObserver(handleMutations);\n      if (container) mutationObserver.observe(container, { childList: true, subtree: true });\n\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n        mutationObserver.disconnect();\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement as HTMLElement | null;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n\n        // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, { select: true });\n          }\n          // we need to remove the listener after we `dispatchEvent`\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n\n  // Takes care of looping focus (when tabbing whilst at the edges)\n  const handleKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      if (!loop && !trapped) return;\n      if (focusScope.paused) return;\n\n      const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n      const focusedElement = document.activeElement as HTMLElement | null;\n\n      if (isTabKey && focusedElement) {\n        const container = event.currentTarget as HTMLElement;\n        const [first, last] = getTabbableEdges(container);\n        const hasTabbableElementsInside = first && last;\n\n        // we can only wrap focus if we have tabbable edges\n        if (!hasTabbableElementsInside) {\n          if (focusedElement === container) event.preventDefault();\n        } else {\n          if (!event.shiftKey && focusedElement === last) {\n            event.preventDefault();\n            if (loop) focus(first, { select: true });\n          } else if (event.shiftKey && focusedElement === first) {\n            event.preventDefault();\n            if (loop) focus(last, { select: true });\n          }\n        }\n      }\n    },\n    [loop, trapped, focusScope.paused]\n  );\n\n  return (\n    <Primitive.div tabIndex={-1} {...scopeProps} ref={composedRefs} onKeyDown={handleKeyDown} />\n  );\n});\n\nFocusScope.displayName = FOCUS_SCOPE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Attempts focusing the first element in a list of candidates.\n * Stops when focus has actually moved.\n */\nfunction focusFirst(candidates: HTMLElement[], { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, { select });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nfunction getTabbableEdges(container: HTMLElement) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last] as const;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nfunction findVisible(elements: HTMLElement[], container: HTMLElement) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!isHidden(element, { upTo: container })) return element;\n  }\n}\n\nfunction isHidden(node: HTMLElement, { upTo }: { upTo?: HTMLElement }) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement as HTMLElement;\n  }\n  return false;\n}\n\nfunction isSelectableInput(element: any): element is FocusableTarget & { select: () => void } {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\n\nfunction focus(element?: FocusableTarget | null, { select = false } = {}) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({ preventScroll: true });\n    // only select if its not the same element, it supports selection and we need to select\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)\n      element.select();\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\n\ntype FocusScopeAPI = { paused: boolean; pause(): void; resume(): void };\nconst focusScopesStack = createFocusScopesStack();\n\nfunction createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */\n  let stack: FocusScopeAPI[] = [];\n\n  return {\n    add(focusScope: FocusScopeAPI) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n\n    remove(focusScope: FocusScopeAPI) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    },\n  };\n}\n\nfunction arrayRemove<T>(array: T[], item: T) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\n\nfunction removeLinks(items: HTMLElement[]) {\n  return items.filter((item) => item.tagName !== 'A');\n}\n\nconst Root = FocusScope;\n\nexport {\n  FocusScope,\n  //\n  Root,\n};\nexport type { FocusScopeProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}