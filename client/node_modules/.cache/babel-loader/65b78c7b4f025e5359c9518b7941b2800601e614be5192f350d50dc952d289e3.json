{"ast":null,"code":"\"use strict\";\n\nvar t = Object.defineProperty;\nvar i = Object.getOwnPropertyDescriptor;\nvar f = Object.getOwnPropertyNames;\nvar a = Object.prototype.hasOwnProperty;\nvar D = (r, e) => {\n    for (var o in e) t(r, o, {\n      get: e[o],\n      enumerable: !0\n    });\n  },\n  y = (r, e, o, p) => {\n    if (e && typeof e == \"object\" || typeof e == \"function\") for (let n of f(e)) !a.call(r, n) && n !== o && t(r, n, {\n      get: () => e[n],\n      enumerable: !(p = i(e, n)) || p.enumerable\n    });\n    return r;\n  };\nvar P = r => y(t({}, \"__esModule\", {\n  value: !0\n}), r);\nvar l = {};\nD(l, {\n  breakpoints: () => s\n});\nmodule.exports = P(l);\nconst s = [\"initial\", \"xs\", \"sm\", \"md\", \"lg\", \"xl\"];","map":{"version":3,"names":["l","D","breakpoints","s","module","exports","P"],"sources":["/Users/catiecook/Documents/workos/frontend-take-home/client/node_modules/@radix-ui/themes/src/props/prop-def.ts"],"sourcesContent":["import type React from 'react';\n\n// Creates a union type of string literals with strings, but retains intellisense for the literals.\n// Union<string, 'foo' | 'bar'> => string | Omit<string, 'foo' | 'bar'>\ntype Union<S = string, T extends string | number = string> = T | Omit<S, T>;\n\nconst breakpoints = ['initial', 'xs', 'sm', 'md', 'lg', 'xl'] as const;\ntype Breakpoint = (typeof breakpoints)[number];\ntype Responsive<T> = T | Partial<Record<Breakpoint, T>>;\n\ntype BooleanPropDef = {\n  type: 'boolean';\n  default?: boolean;\n  required?: boolean;\n  className?: string;\n};\ntype StringPropDef = {\n  type: 'string';\n  default?: string;\n  required?: boolean;\n};\ntype ReactNodePropDef = {\n  type: 'ReactNode';\n  default?: React.ReactNode;\n  required?: boolean;\n};\ntype EnumPropDef<T> = {\n  type: 'enum';\n  values: readonly T[];\n  default?: T;\n  required?: boolean;\n};\ntype EnumOrStringPropDef<T> = {\n  type: 'enum | string';\n  values: readonly T[];\n  default?: T | string;\n  required?: boolean;\n};\n\ntype NonStylingPropDef = {\n  className?: never;\n  customProperties?: never;\n  parseValue?: never;\n};\n\ntype StylingPropDef = {\n  className: string;\n  parseValue?: (value: string) => string | undefined;\n};\n\ntype ArbitraryStylingPropDef = {\n  className: string;\n  customProperties: `--${string}`[];\n  parseValue?: (value: string) => string | undefined;\n};\n\ntype RegularPropDef<T> =\n  | ReactNodePropDef\n  | BooleanPropDef\n  | (StringPropDef & ArbitraryStylingPropDef)\n  | (StringPropDef & NonStylingPropDef)\n  | (EnumPropDef<T> & StylingPropDef)\n  | (EnumPropDef<T> & NonStylingPropDef)\n  | (EnumOrStringPropDef<T> & ArbitraryStylingPropDef)\n  | (EnumOrStringPropDef<T> & NonStylingPropDef);\ntype ResponsivePropDef<T = any> = RegularPropDef<T> & { responsive: true };\ntype PropDef<T = any> = RegularPropDef<T> | ResponsivePropDef<T>;\n\n// prettier-ignore\ntype GetPropDefType<Def> =\n    Def extends BooleanPropDef ? (Def extends ResponsivePropDef ? Responsive<boolean> : boolean)\n  : Def extends StringPropDef ? (Def extends ResponsivePropDef ? Responsive<string> : string)\n  : Def extends ReactNodePropDef ? (Def extends ResponsivePropDef ? Responsive<React.ReactNode> : React.ReactNode)\n  : Def extends EnumOrStringPropDef<infer Type> ?\n    Def extends ResponsivePropDef<infer Type extends string> ? Responsive<Union<string, Type>> : Type\n  : Def extends EnumPropDef<infer Type> ? (Def extends ResponsivePropDef<infer Type> ? Responsive<Type> : Type)\n  : never;\n\ntype GetPropDefTypes<P> = {\n  [K in keyof P]?: GetPropDefType<P[K]>;\n};\n\nexport { breakpoints };\nexport type {\n  PropDef,\n  GetPropDefTypes,\n  ResponsivePropDef,\n  //\n  Breakpoint,\n  Responsive,\n  Union,\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,IAAAA,CAAA;AAAAC,CAAA,CAAAD,CAAA;EAAAE,WAAA,EAAAA,CAAA,KAAAC;AAAA;AAAAC,MAAA,CAAAC,OAAA,GAAAC,CAAA,CAAAN,CAAA;AAMA,MAAMG,CAAA,GAAc,CAAC,WAAW,MAAM,MAAM,MAAM,MAAM,IAAI","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}